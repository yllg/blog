---
title: 移动端开发常见问题汇总
categories:
  - 前端跨界
  - null
tags:
  - null
  - null
date: 2020-05-18 10:03:48
top:
---

# 一．开发调试
## 1.Eruda库，star 8.4K
迷你版的devtool，编程猫kitten的pad版用这个进行真机调试
在开发和测试环境使用，生产环境无法使用；

## 2.Vconsole, star 11.4k 腾讯出品
方便使用，同样只适用于开发和测试环境；
```bash
import Vconsole from 'vconsole'
new Vconsole()
```

## 3.代理+spy-debugger，star 4.9k
（1）最大的优点是很方便调试<font color="#FF0000"> 线上生产环境 </font>，不需要修改代码；
（2）GitHub仓库：
https://github.com/wuchangming/spy-debugger
（3）使用步骤大概这五步
{% blockquote %}
* 手机和PC保持在同一网络下（比如同时连到一个Wi-Fi下）
* 命令行输入spy-debugger，按命令行提示用浏览器打开相应地址。
* 设置手机的HTTP代理，代理IP地址设置为PC的IP地址，端口为spy-debugger的启动端口(默认端口：9888)。
Android设置代理步骤：设置 - WLAN - 长按选中网络 - 修改网络 - 高级 - 代理设置 - 手动
iOS设置代理步骤：设置 - 无线局域网 - 选中网络 - HTTP代理手动
* 手机安装证书。
注：手机必须先设置完代理后再通过(非微信)手机浏览器访问http://s.xxx(地址二维码)安装证书（手机首次调试需要安装证书，已安装了证书的手机无需重复安装)。iOS新安装的证书需要手动打开证书信任
* 用手机浏览器访问你要调试的页面即可。
{% endblockquote %}


# 二．与原生交互
## 1.与原生交互，JSbridge和DSBridge
JSbridge比较常用，介绍下DSBridge

## 2.DSBridge是2019年国产开源的新项目，号称最好用的JS bridge
主要特点如下：
1.跨平台；同时支持ios和android。
2.双向调用；js可以调用native， native可以调用js
3.不仅支持异步调用，而且页支持<font color="#FF0000"> 同步调用 </font>
dsbridge是唯一一个支持同步调用的javascript bridge
4.支持进度回调，多次返回（常用于文件下载进度、计时器等）
5.Android支持腾讯x5内核
6.三端易用；无论是前端还是android或ios，使用都非常简单，极大的降低集成／学习成本
7.DSBridge为国人项目，有详细中文文档和问题反馈渠道。

## 3.DSBridge基本使用
（1）注册方法 bridge.register
```bash
bridge.register('enterApp', function() {
  broadcast.emit('ENTER_APP')
})
```
(2)回调方法 bridge.call
```bash
export const getSDKVersion = () => bridge.call('BLT.getSDKVersion')
```
(3)事件监听与触发
```bash
const broadcast = {
  on: function(name, fn, pluralable) {
    this._on(name, fn, pluralable, false)
  },
  once: function(name, fn, pluralable) {
    this._on(name, fn, pluralable, true)
  },
  _on: function(name, fn, pluralable, once) {
    let eventData = broadcast.data
    let fnObj = { fn: fn, once: once }
    if (pluralable && Object.prototype.hasOwnProperty.call(eventData, 'name')) {
      eventData[name].push(fnObj)
    } else {
      eventData[name] = [fnObj]
    }
    return this
  },
  emit: function(name, data, thisArg) {
    let fn, fnList, i, len
    thisArg = thisArg || null
    fnList = broadcast.data[name] || []
    for (i = 0, len = fnList.length; i < len; i++) {
      fn = fnList[i].fn
      fn.apply(thisArg, [data, name])
      if (fnList[i].once) {
        fnList.splice(i, 1)
        i--
        len--
      }
    }
    return this
  },
  data: {}
}
export default broadcast
```



# 三．IOS的问题
## 1.IOS产品上架审核的问题
三大类：
### 应用内功能设置
1、应用内包含检查更新功能
2、使用第三方登录时未做安装检测
3、采集设备IDFA但应用没有广告功能
4、含UGC却未提供用户协议及举报功能
5、必须使用邀请码才能注册使用
6、应用内出现其他移动平台的名字或图标
7、应用内涉及奖励，未声明与苹果无关
8、未注册时不能使用与账号无关的功能
9、注册缺少隐私政策
10、iPhone 应用在 iPad 上不能正常显示
11、应用包含应用推荐功能

### 上传审核类
1、上传时没有使用真实的应用截图
2、应用出现 beta版、测试版字样
3、应用描述、截图和应用功能不符
4、应用截图、名称、描述等出现不雅词汇
5、应用作者名与金融机构名字不一致

### App Store的其他规定
1、侵犯第三方版权
2、应用出现崩溃、加载失败等bug
3、应用提交的新版本与上一版差异过大
4、应用违反当地法律法规


## 2.滚动不流畅
### 2-1.表现
上下滑动页面会产生卡顿，手指离开页面，页面<font color="#FF0000"> 立即停止运动 </font>。整体表现就是滑动不流畅，没有滑动惯性。

### 2-2.原因
safari 文档里有写
![](1.webp)
在 iOS 5.0 以及之后的版本，滑动有定义有两个值 auto 和 touch，默认值为 auto。

```bash
-webkit-overflow-scrolling: touch; /* 当手指从触摸屏上移开，会保持一段时间的滚动 */
-webkit-overflow-scrolling: auto; /* 当手指从触摸屏上移开，滚动会立即停止 */
```

### 2-3.解决方案

（1）在滚动容器上增加滚动 <font color="#FF0000"> touch </font> 方法
将-webkit-overflow-scrolling 值设置为 touch
```bash
.wrapper {
    -webkit-overflow-scrolling: touch;
}
```
设置滚动条隐藏： .container ::-webkit-scrollbar {display: none;}
问题：可能会导致使用position:fixed; 固定定位的元素，随着页面一起滚动

（2）设置 overflow
设置外部 overflow 为 hidden,设置内容元素 overflow 为 auto。内部元素超出 body 即产生滚动，超出的部分 body 隐藏。
```bash
body {
    overflow-y: hidden;
}
.wrapper {
    overflow-y: auto;
}
```
上面两种方案结合使用更佳！



## 3.iPhone X+的刘海屏适配
### 3-1 表现
头部刘海两侧区域或者底部区域，出现刘海遮挡文字，或者呈现黑底或白底空白区域。
### 3-2 原因
iPhone X 以及它以上的系列，都采用刘海屏设计和全面屏手势。头部、底部、侧边都需要做特殊处理。才能适配 iPhone X 的特殊情况。
### 3-3 解决方案
设置安全区域，填充危险区域，危险区域不做操作和内容展示。
{% blockquote %}
危险区域：指头部不规则区域，底部横条区域，左右触发区域。
{% endblockquote %}

![](4.webp)

具体操作为：<font color="#FF0000"> viewport-fit </font> meta 标签设置为 <font color="#FF0000"> cover </font> ，获取所有区域填充。判断设备是否属于 iPhone X，给头部底部增加适配层

{% blockquote %}
viewport-fit 有 3 个值分别为：
auto：此值不影响初始布局视图端口，并且整个web页面都是可查看的。
contain：视图端口按比例缩放，以适合显示内嵌的最大矩形。
cover：视图端口被缩放以填充设备显示。强烈建议使用 safe area inset 变量，以确保重要内容不会出现在显示之外。
{% endblockquote %}

（1）设置 viewport-fit 为 cover
```bash
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes, viewport-fit=cover">
```
（2）增加适配层
使用 <font color="#FF0000"> safe area inset </font>变量
```bash
/* 适配 iPhone X 顶部填充*/
@supports (top: env(safe-area-inset-top)){
  body,
  .header{
      padding-top: constant(safe-area-inset-top, 40px);
      padding-top: env(safe-area-inset-top, 40px);
      padding-top: var(safe-area-inset-top, 40px);
  }
}
/* 判断iPhoneX 将 footer 的 padding-bottom 填充到最底部 */
@supports (bottom: env(safe-area-inset-bottom)){
    body,
    .footer{
        padding-bottom: constant(safe-area-inset-bottom, 20px);
        padding-bottom: env(safe-area-inset-bottom, 20px);
        padding-top: var(safe-area-inset-bottom, 20px);
    }
}
```

{% blockquote %}
MDN文档:
safe-area-inset-top, safe-area-inset-right, safe-area-inset-bottom, safe-area-inset-left safe-area-inset-*由四个定义了视口边缘内矩形的 top, right, bottom 和 left 的环境变量组成，这样可以安全地放入内容，而不会有被非矩形的显示切断的风险。对于矩形视口，例如普通的笔记本电脑显示器，其值等于零。对于非矩形显示器（如圆形表盘，iPhoneX 屏幕），在用户代理设置的四个值形成的矩形内，所有内容均可见。
{% endblockquote %}

其中 env() 用法为 env( <custom-ident> , <declaration-value>? )，第一个参数为自定义的区域，第二个为备用值。

其中 var() 用法为 var( <custom-property-name> , <declaration-value>? )，作用是在 env() 不生效的情况下，给出一个备用值。

constant（） 被 css 2017-2018 年为草稿阶段，是否已被标准化未知。而其他iOS 浏览器版本中是否有此函数未知，作为兼容处理而添加进去。


## 4.Safari中base64的图片没有显示，加载失败
### 4-1.原因
使用JS通过img.style.backgroundImage获取图片的base64 url
Safari和chrome的<font color="#FF0000"> 结果值 </font>不一样
chrome中格式，url("https://static.codemao.cn/xxx")
safari中格式，url(https://static.codemao.cn/xxx) 括号内是没有引号

### 4-2.解决方法
要取出括号内不带引号的url链接，if分两种情况处理即可


## 5.Safari中元素的水平垂直居中css样式不生效
### 垂直水平居中方案大全，6种
1.父级设置text-align: center和line-height等同高度。
2.子节点绝对定位，设置position: absolute;top: 50%;left: 50%;transform: translate(-50%, -50%);
3.子节点绝对定位，需要设置宽度和高度。设置position: absolute;top:0;left:0;right:0;bottom:0;margin:auto;
4.父级设置display: table，子节点设置display:table-cell;text-align:center;vertical-align:middle;
5.父级设置display: flex;justify-content:center;align-items:center;
6.父节点设置display: grid;，子节点设置：align-self:center;justify-self: center;

使用最常用的 方法2 和 方法3 在Safari中都无效

### 解决方案
Safari中必须设置<font color="#FF0000"> 父元素 position:relative </font>


## 6.去掉IOS中input和textarea表单 默认的内阴影
一行样式搞定
```bash
input{
  -webkit-appearance: none;
}
```


# 四．Android的问题
## 1.webwiew中window的resize事件不触发
### 1-1.表现
原生 注册事件
window.onresize = func();

JQ 触发事件
$(window).resize();

IOS中能触发func，但是<font color="#FF0000"> 安卓中不会触发 </font>

### 1-2.解决方案
统一使用JQ来注册和触发事件
```bash
$(window).resize(() => {
  this.kitten_resize();
});
$(window).resize();
```

# 五．IOS和安卓都有的问题

## 1.缩放不确定性
### 1-1 表现
<font color="#FF0000"> 双击或者双指张开 </font>手指页面元素，页面会放大或缩小。
### 1-2 原因
HTML 本身会产生放大或缩小的行为，比如在 PC 浏览器上，可以自由控制页面的放大缩小。
但是在移动端，我们是不需要这个行为的。
所以，我们需要<font color="#FF0000"> 禁止 </font>该不确定性行为，来提升用户体验。
### 1-3 解决方案
HTML meta 元标签标准中有个 中 <font color="#FF0000"> viewport </font> 属性，用来控制页面的缩放，一般用于移动端。
![](2.webp)

移动端常规写法
```bash
<meta name="viewport" content="width=device-width, initial-scale=1.0">
```
我们可以设置 <font color="#FF0000"> maximum-scale </font>、<font color="#FF0000"> minimum-scale </font> 与 <font color="#FF0000"> user-scalable=no </font> 用来避免这个问题
```bash
<meta name=viewport
  content="width=device-width, initial-scale=1.0, minimum-scale=1.0 maximum-scale=1.0, user-scalable=no">
```


## 2.click点击事件延迟与穿透
### 2-1 表现
监听元素 click 事件，点击元素触发时间<font color="#FF0000"> 延迟约 300ms </font>。
点击蒙层，蒙层消失后，<font color="#FF0000"> 下层元素 </font>点击触发。

### 2-2 原因
（1）为什么会产生 click 延时？
iOS 中的 safari，为了实现<font color="#FF0000"> 双击缩放 </font>操作，在单击 300ms 之后，如果未进行第二次点击，则执行 click 单击操作。也就是说来判断用户行为是否为双击产生的。
但是，在 App 中，无论是否需要双击缩放这种行为，click 单击都会产生 300ms 延迟。

（2）为什么会产生 click 点击穿透？
双层元素叠加时，在上层元素上绑定 touch 事件，下层元素绑定 click 事件。
由于 <font color="#FF0000"> click 发生在 touch 之后 </font>，点击上层元素，元素消失，下层元素会触发 click 事件，由此产生了点击穿透的效果。

### 2-3 解决方案
（1）css方案：
touch-action的默为 auto，将其置为 none,即可移除目标元素的 300 毫秒延迟；
缺点: <font color="#FF0000"> 新属性 </font>，可能存在浏览器兼容问题

（2）使用touchstart和touchend来模拟代click；
在原生中使用
```bash
el.addEventListener("touchstart", () => { console.log("ok"); }, false);
```

（3）使用fastclick库；
```bash
import FastClick from 'fastclick';
FastClick.attach(document.body, options);
```

原理：在检测到touchend事件的时候，会通过DOM自定义事件立即出发<font color="#FF0000"> 模拟 </font>一个click事件，并把浏览器在300ms之后真正的click事件<font color="#FF0000"> 阻止掉 </font>

（4）所有版本的Android Chrome浏览器，如果设置viewport meta的值有<font color="#FF0000"> user-scalable=no </font>，浏览器也是会马上出发点击事件；


## 3.上拉下拉有空白
### 3-1 表现
手指按住屏幕下拉，屏幕顶部会多出一块白色区域。手指按住屏幕上拉，底部多出一块白色区域。
### 3-2 原因
在 iOS 中，手指按住屏幕上下拖动，会触发 touchmove 事件。这个事件触发的对象是<font color="#FF0000"> 整个 webview 容器 </font>，容器自然会被拖动，剩下的部分会成空白。
### 3-3 解决方案
1.监听事件禁止滑动
<font color="#FF0000"> preventDefault </font> 方法，阻止同一触点上所有默认行为，包括滚动。
通过监听 touchmove，让需要滑动的地方滑动，不需要滑动的地方禁止滑动
注意要过滤掉具有滚动容器的元素。

```bash
document.body.addEventListener('touchmove', function(e) {
    if(e._isScroller) return;
    // 阻止默认事件
    e.preventDefault();
}, {
    passive: false
});
```

2.滚动妥协，填充空白，<font color="#FF0000"> 装饰 </font>成其他功能
在很多时候，我们可以不去解决这个问题，换一直思路。根据场景，我们可以将下拉作为一个功能性的操作。
最常见的就是下拉刷新页面, 京东美团很多APP都有
![](3.webp)


## 4.键盘把页面顶起来，不回落
### 4-1 表现
点击 input 框时，键盘弹出，将页面顶起来，导致页面样式错乱。
移开焦点时，键盘收起，键盘区域空白，页面未回落。

### 4-2 原因
我们在app 布局中会有个固定的底部。安卓和IOS一些版本中，输入弹窗出来，会将解压 absolute 和 fixed 定位的元素。导致可视区域变小，布局错乱。

### 4-3 解决方案
（1）软键盘将页面顶起来的解决方案
主要是通过监听页面高度变化，<font color="#FF0000"> 强制恢复 </font>成弹出前的高度。
```bash
// 记录原有的视口高度
const originalHeight = document.body.clientHeight || document.documentElement.clientHeight;

window.onresize = function(){
  var resizeHeight = document.documentElement.clientHeight || document.body.clientHeight;
  if(resizeHeight < originalHeight ){
    // 恢复内容区域高度
    // const container = document.getElementById("container")
    // 例如 container.style.height = originalHeight;
  }
}
```

(2)键盘收起后页面不能回落问题
出现在 iOS 12+ 和 wechat 6.7.4+ 中，而在微信 H5 开发中是比较常见的 Bug。
兼容原理
1.判断版本类型 
2.<font color="#FF0000"> 更改滚动 </font>的可视区域

```bash
const isWechat = window.navigator.userAgent.match(/MicroMessenger\/([\d\.]+)/i);
if (!isWechat) return;
const wechatVersion = wechatInfo[1];
const version = (navigator.appVersion).match(/OS (\d+)_(\d+)_?(\d+)?/);
 
 // 如果设备类型为iOS 12+ 和wechat 6.7.4+，恢复成原来的视口
if (+wechatVersion.replace(/\./g, '') >= 674 && +version[1] >= 12) {
  window.scrollTo(0, Math.max(document.body.clientHeight, document.documentElement.clientHeight));
}
```

window.scrollTo(x-coord, y-coord)，其中window.scrollTo(0, clientHeight)恢复成原来的视口



## 5.1px 问题
### 5-1.各种概念
（1）对于一种影像设备(如液晶电视/电脑屏幕)，<font color="#FF0000"> 物理像素 </font>是固定的单位，而<font color="#FF0000"> 逻辑像素 </font>是相对单位，如CSS中的px。
（2）公式
DPR: 独立像素比(设备像素比) =
  分辨率(设备像素数如1920*1080) ➗ 设备独立像素数/CSS像素数(如1280*610)
（3）DPR一般也是每个设备固定的，在100%缩放的情况下，1个设备独立像素就等于1个CSS像素，因此每个设备的DPR可以看作是固定的。
（4）注意：上面的除法不是乘起来除，而是1920÷1280或者1080÷610，即（在相同长度的直线上）设备像素的数量 / CSS像素的数量。
（5）同时DPR也等价于：每个CSS像素边长 ➗ 每个设备像素边长；怎么反过来了呢，因为在尺寸不变的情况下，像素数和每个像素的边长成反比，

### 5-2.移动端1px问题
（）上面的理论得知，逻辑像素是 1pt 时，在 DPR 为 2 的 设备上显示为 2px 的物理像素
问题就是如何实现<font color="#FF0000"> 物理像素的1px </font>；
（）主流的两种解决方案
1）利用 css 中的transfrom：<font color="#FF0000"> scaleY </font>(0.5)，
2）另一种是设置<font color="#FF0000"> 媒体查询 </font>根据不同 DPR 缩放
（）其他方案
3）使用图片，不能改颜色和长度；
4）使用 viewport 和 rem，js 动态改变 viewport 中 scale 缩放，缺点在于不适用于已有的项目
5）使用 css 渐变linear-gradient或者box-shadow


## 6.响应式布局
### 6-1 媒体查询@media
略
### 6-2 px、em、rem
1.px像素（Pixel）
相对长度单位，相对于显示器屏幕分辨率而言的；
2.em
也是相对长度， em会继承父级元素的字体大小
3.rem
CSS3新增的一个相对单位（root em，根em）
仍然是相对大小，但相对的只是<font color="#FF0000"> HTML根元素 </font>。
这个单位可谓集相对大小和绝对大小的优点于一身，通过它既可以做到只修改根元素就成比例地调整所有字体大小，又可以避免字体大小逐层复合的连锁反应。


## 7.web端hover和点击事件，在移动端兼容
### 7-1.hover事件
长按事件代替hover事件
### 7-2.点击事件
点击事件可以保持不变，延迟和穿透的问题见上面
### 7-3.其他
onTouchStart模拟mouseover
onTouchEnd模拟mouseout
### 7-4.补充 mouseout、mouseover和mouseleave、mouseenter的区别
（1）不论鼠标指针穿过被选元素或其子元素，都会触发 mouseover 事件。对应mouseout
（2）只有在鼠标指针穿过被选元素时，才会触发 mouseenter 事件。对应mouseleave
（3）区别：<font color="#FF0000"> 子元素连带触发 </font>，冒泡；



# 六．微信端的问题
## 1.公众号分享
### 1-1 表现
在微信公众号 H5 开发中，页面内部点击分享按钮调用 SDK，方法不生效。
### 1-2 解决方案
<font color="#FF0000"> 添加一层蒙层，做分享引导 </font>。

因为页面内部点击分享按钮无法直接调用，而分享功能需要点击右上角更多来操作。
然后用户可能不知道通过右上角小标里面的功能分享。又想引导用户分享，这时应该怎么做呢？

技术无法实现的，从产品出发。
![](5.webp)

{% blockquote %}
如果技术上实现复杂，或者直接不能实现。不要强行钻牛角尖，学会怼产品，也是程序员必备的技能
{% endblockquote %}


## 2.保存页面的二维码/图片
## 2-1 表现
在工作中有需要将页面生成图片或者二维码的需求。
可能我们第一想到的，交给后端来生成更简单。但是这样我们需要把页面代码全部传给后端，网络性能消耗太大。

## 2-2 解决方案
### 2-2-1 使用 QRCode 生成二维码
```bash
import QRCode from 'qrcode';
// 使用 async 生成图片
const options = {};
const url = window.location.href;
async url => {
  try {
    console.log(await QRCode.toDataURL(url, options))
  } catch (err) {
    console.error(err);
  }
}
```
将 <font color="#FF0000"> await QRCode.toDataURL(url, options) </font> 赋值给 图片 url 即可

### 2-2-2 生成图片
使用htmlToCanvas 生成 canvas 画布

```bash
import html2canvas from 'html2canvas';

html2canvas(document.body).then(function(canvas) {
    document.body.appendChild(canvas);
});
```

但是不单单在此处就完了，由于是 canvas 的原因。移动端生成出来的图片比较模糊。

我们使用一个新的 canvas 方法<font color="#FF0000"> 多倍生成 </font> ，放入一倍容器里面，达到更加清晰的效果

```bash
// 根据需要设置 scaleSize 大小
const scaleSize = 2;
const newCanvas = document.createElement("canvas");
const target = document.querySelector('div');
const width = parseInt(window.getComputedStyle(target).width);
const height = parseInt(window.getComputedStyle(target).height);
newCanvas.width = width * scaleSize;
newCanvas.height = widthh * scaleSize;
newCanvas.style.width = width + "px";
newCanvas.style.height =width + "px";
const context = newCanvas.getContext("2d");
context.scale(scaleSize, scaleSize);
html2canvas(document.querySelector('.demo'), { canvas: newCanvas }).then(function(canvas) {
  // 简单的通过超链接设置下载功能
  document.querySelector(".btn").setAttribute('href', canvas.toDataURL());
}
```



**【0521 更新】** 

# 七．webview相关
## 1.webview
Andoid 平台，SDK 中有一个控件叫 WebView；
IOS/MacOS 平台，SDK 中有一个控件叫 WebView/UIWebView/WKWebView(UIView/NSView)；
这些控件，用于移动端 APP 嵌入(Embed) Web 技术，加载 Web 内容

简单理解：
WebView就是<font color="#FF0000"> 嵌套在原生应用 </font>里的一个浏览器

## 2.浏览器内核
### （1）组成
主要分为<font color="#FF0000"> 渲染引擎 </font>和<font color="#FF0000"> JS引擎 </font>
### （2）渲染引擎
2013 年以前，常见的浏览器内核代表有 Trident（IE），Gecko（firefox）， <font color="#FF0000"> Webkit </font> （Safari chrome 等）以及 Presto（opera)。

2013 年，谷歌开始研发 <font color="#FF0000"> blink </font> 引擎，chrome 28 以后开始使用，而 opera 则放弃了自主研发的 Presto 引擎，投入谷歌怀抱，和谷歌一起研发 blink 引擎，国内各种 chrome系的浏览器（360、UC、QQ、百度等等）也纷纷放弃 webkit，投入 blink 的怀抱。

安卓的webview内核的渲染引擎，<font color="#FF0000"> 4.4 </font>开始由webkit转成Blink，下面会详细介绍；

### （3）JS引擎
及时常说的V8引擎

### （4）Chromium内核
Chromium内核：
谷歌从一个 WebKit 分支基础上逐渐走上了自研的道路，采用<font color="#FF0000">  Blink 渲染引擎和 V8 JavaScript 引擎 </font>打造的内核；

## 3.查看webview的内核
（1）设置-->应用程序管理-->全部-->Android System WebView
有的机型可能看不到，比如华硕安卓6.0的平板就没找到；
（2）在app的webview中输入 https://liulanmi.com/labs/core.html
（3）adb指令查看(前提，已安装android sdk环境)
命令行输入
adb shell am start -a android.intent.action.VIEW -d  https://liulanmi.com/labs/core.html

## 4.安卓webview相关
（1）Android <font color="#FF0000"> 4.4 </font>，原本基于 Android WebKit 的 WebView 实现被换成基于Chromium的实现，内部的渲染引擎改为使用基于 Blink/Content 内核的引擎，功能和性能都带来巨大的提升。

（2）Android  开始，Google 把 Chromium blink内核 webview 作为 <font color="#FF0000"> apk </font> 单独从系统抽离出去，可在<font color="#FF0000"> 应用市场上面安装更新 </font>。
应用可以直接使用该webview内核，Google也可以及时发布更新，不用再通过更新系统才能更新浏览器内核，避免了 Android 系统碎片化问题。

（3）国内安卓浏览器内核的问题
Android 系统开源但 Google 提供的基础服务在国内无法使用的情况下，国内厂商往往抛弃了 Google 既有的规范，对系统进行了大量的定制，导致设备ROM 与原生 Android 系统环境差异性巨大；

浏览器内核也是如此，即便是Google推出了基于 Chromium blink 内核实现的 WebView，但是很多国内厂商对其进行了<font color="#FF0000"> 精简或替代 </font>，导致 WebView 内核也是<font color="#FF0000"> 碎片化问题严重 </font>。

## 5.目前移动端H5适配的问题
### （1）旧机型
就算h5页面中图片与文本信息并不多,但在WebView中展示的时候都会出现<font color="#FF0000"> 拖拽不流畅，切换留白、窗口闪烁 </font>等的现象，这是 WebView <font color="#FF0000"> 自身渲染能力不强 </font>的问题所致。
### （2）Html5的Video控件播放视频
iOS点击视频部分，会用系统自带的浏览器全屏播放视频，体验效果比较好；
而Android的WebView <font color="#FF0000"> 无法全屏等各种问题 </font>，体验效果差一些。
### （3）其他：
<font color="#FF0000"> 页面加载慢 </font>；
偶尔内存泄露；
不同 Android 系统版本采用了不同内核的兼容问题；

## 6.webview的性能优化手段
### （1）webview热启动
1）冷启动：当启动应用时，后台没有该应用的进程，这时系统会重新创建一个新的进程分配给该应用，这个启动方式就是冷启动。
2）热启动：当启动应用时，后台已有该应用的进程（例：按home键回到桌面，但是该应用的进程是依然会保留在后台，可进入任务列表查看），所以在已有进程的情况下，这种启动会从已有的进程中来启动应用，这个方式叫热启动。
### （2）全局WebView
在客户端刚启动时，就<font color="#FF0000"> 初始化一个全局的WebView待用 </font>，并隐藏；
当用户访问了WebView时，直接使用这个WebView加载对应网页，并展示。
### （3）原生客户端代理数据请求
在客户端初始化WebView的同时，直接由<font color="#FF0000"> native开始网络请求数据 </font>
当页面初始化完成后，向native获取其代理请求的数据
### （4）升级版本；
### （5）使用腾讯X5内核；


# 八.腾讯 X5内核优势？解决什么问题？坑有哪些？
## 1.背景
（1）为啥安卓端要考虑浏更换览器内核的问题？
一句话：你是要搞定<font color="#FF0000"> 一个 X5 </font> 上的兼容性问题，还是要搞定<font color="#FF0000"> 几百台安卓手机 </font>上的兼容性问题；
（2）X5 内核就是基于 <font color="#FF0000"> Android 5.0 WebView Blink内核 </font>（M37版本）适配定制优化；

## 2.优势，腾讯X5官网自己的介绍
（1）速度快：相比系统webView的网页加载速度有近30%的提升。
部分页面预加载缓存控制
（2）省流量：云端优化技术使流量节省20%
（3）更安全：24小时安全问题解决机制
（4）更稳定：经过亿级用户的使用考验，CRASH率0.15%
（5）集成强大的视频播放器，支持各种视频格式直接打开，播放更流畅
（6）适屏排版、字体设置等浏览增强功能的提供
（7）Html5更完整支持。
（8）无系统内核的碎片化问题，更少的兼容性问题 X5云端服务是通过云端技术保证用户在未装QQ浏览器的情况下同样可以使用X5内核提供的优秀服务，包括云加速、云安全、云转换三大功能。

## 3.X5的坑
夸了一波，当然X5也有很多坑，知乎上也是被各种骂；
（1）video各种问题，video劫持，不让写入canvas等等。
（2）视频弹幕无法播放问题；
（3）返回上一页强制使用缓存；
（4）cookies清理机制等等；
等等等等，可以自行搜索；



~ ~ 持续更新 ~ ~


参考文献：
https://mp.weixin.qq.com/s/nMg4jLpbDUt396Lz_YVlhA
https://blog.csdn.net/weixin_34279184/article/details/93166384
https://juejin.im/post/5cb82db051882534567149f1
https://juejin.im/post/5a3522f2f265da431440c632

同时欢迎关注我的个人微信公众号：
{% img https://www.xuanbiyijue.com//img/%E5%85%AC%E4%BC%97%E5%8F%B7%E4%BA%8C%E7%BB%B4%E7%A0%81.jpg 300 300 %}   
