---
title: 事件循环、宏任务、微任务一网打尽（附超多经典面试题）
categories:
  - 实验室
  - null
tags:
  - null
  - null
date: 2021-06-06 22:25:47
top:
---

# 宏任务和微任务
## 1.宏任务macrotask/Tasks：
### （1）种类：
script主代码块、setTimeout 、setInterval 、nodejs的setImmediate 、MessageChannel（react的fiber用到）、postMessage、网络I/O、文件I/O、用户交互的回调等事件、UI渲染事件（DOM解析、布局计算、绘制）等等
### （2）宏任务的问题，也即为什么要有微任务？
时间粒度比较大，执行的时间间隔是不能精确控制的，消息队列中就有可能被插入很多系统级的任务，对一些高实时性的需求就不太符合了；
所有设计了微任务，通俗的讲微任务可以插队，本轮宏任务最后，插在下一轮宏任务之前，微任务队列的任务一次性全部执行完；

## 2.微任务包括microtask/jobs：
### （1）种类：
- 浏览器端有3个
1）new Promise().then 回调
2）MutationObserver，监控dom节点变化；
MutationObserver使用“异步”+“微任务”的方式，替代旧版mutation event这个同步事件，
异步解决同步操作的性能问题；微任务解决了实时性的问题；
3）Object.observe，已经废弃了，用Proxy对象替代；
- nodejs有2个，process.nextTick、 new Promise().then 回调

### （2）优先级如下：
nodejs中process.nextTick >new Promise().then(回调) > MutationObserver

### （3）宏任务和微任务的关系
每个宏任务可以创建自己的一个微任务队列；

{% asset_img ClassName 1.png %}

## 3.一个宏任务微任务的例子，理解用户点击事件和JS模拟点击事件的区别

```js
.body.innerHTML = `
  <button id="btn" type="button">btn</button>
`; 
const button = document.getElementById('btn')
button.addEventListener('click',()=>{
 Promise.resolve().then(()=>console.log('promise resolved 1'))
 console.log('listener 1')
})
button.addEventListener('click',()=>{
 Promise.resolve().then(()=>console.log('promise resolved 2'))
 console.log('listener 2')
})
// 1. 手动点击按钮
// button.click() // 2. 解开这句注释，用JS触发点击行为
```

- 当我们使用  手动点击按钮时，浏览器的输出是
 listener1 -> promise resolved 1 -> listener2 -> promise resolved 2
- 当我们使用 JS触发点击行为时，浏览器的输出是
listener1 -> listener2 -> promise resolved 1 -> promise resolved 2
原因：
### （1）人工点击
{% asset_img ClassName 2.png %}
- 从上图中我们可以看到，一次点击事件之后，浏览器会调用 Function Call 进入JS引擎，执行 listener1，输出 listener1。
- 弹栈时发现JS调用栈为空，这时候就会执行 Microtasks 队列中的所有 Microtask，输出 promise resolved1。
- 接着浏览器调用 Function Call 进入JS引擎，执行 listener2，输出 listener2。
- 弹栈时发现JS调用栈为空，这时候就会执行 Microtasks 队列中的所有Microtask，输出 promise resolved2。
- 
### （2）JS触发点击事件
{% asset_img ClassName 3.png %}

- 从上图中我们可以看到，浏览器运行JS代码时，调用了 button.click 这个函数
- 进入事件处理，执行 listener1，输出 listener1。
- 弹栈时发现JS调用栈非空（button.click函数还在运行）
- 执行 listener2，输出 listener2。
- 弹栈时发现JS调用栈为空，这时候就会执行 Microtasks 队列中的所有 Microtask，输出 promise resolved1、 promise resolved2。

## 4.调试V8源码的微任务
使用工具，chrome://tracing/ 是一个 structural profiler 或叫 CPU profiler，与 Chrome Devtool performance 的 sample profiler 不同，他是由代码中主动的去埋点打印出来的，所以每一次函数调用都会被记录下来，不会像sample profiler一样漏掉采样时刻之间的状态。
具体使用步骤可自行谷歌；

## 5.任务队列和回调函数的区别
（1）Javascript单线程任务被分为同步任务和异步任务
同步任务会在调用栈中按照顺序等待主线程依次执行，
异步任务会在异步任务有了结果后，将注册的回调函数放入任务队列中等待主线程空闲的时候（调用栈被清空），被读取到栈内等待主线程的执行。
（2）异步任务都能注册回调函数
比如nodejs的setImmediate、MessageChannel、setTimeout、setInterval、
process.nextTick 、new Promise().the(回调) 、 MutationObserver等等
（3）任务队列分为：宏任务队列，微任务队列；

## 6.settimeout、setinterval的几个注意点：
（1）当前任务执行时间过久，会影响定时器任务的执行
下面这个例子会有两种结果：
settimeout(a, 3000); …同步代码执行很久;再一个 settimeout(b, 1000)
同步代码执行时间 <= 3000，顺序执行，先b再a；可以把同步看做很快执行完；
同步代码执行时间 > 3000执行完后，先a再b；
（2）chrome中最低延时是<font color="#FF0000"> 1ms </font>；即设置0最低为1ms；
因为设置0的话，可能会导致JS单进程event loop过度循环，阻塞；
（3）setTimeout 存在嵌套调用
chrome中超过5层，系统会设置最短时间间隔为<font color="#FF0000"> 4 </font>  毫秒，setinterval是10毫秒；
最开始是1ms，太低会导致计算机没法进入睡眠模式，耗电非常快，所以改成4ms；
（4）未激活的页面，setTimeout 执行最小间隔是 <font color="#FF0000"> 1000 </font> 毫秒，减少加载损耗，节约电量；
（5）延时执行时间有最大值
32 个 bit 来存储延时值的，最大只能存放的数字是 <font color="#FF0000"> 2147483647 </font> 毫秒，
超过这个值会溢出，相当于延时值被设置为 0 了，这导致定时器会被立即执行。
（6）第一个参数除了可以传函数，还可以直接传递<font color="#FF0000"> code字符串 </font>，下面一个例子
setTimeout(1)和setTimeout(2)的区别
首先语法如下：
```js
var timeoutID = scope.setTimeout(function[, delay, arg1, arg2, ...]);
var timeoutID = scope.setTimeout(function[, delay]);
var timeoutID = scope.setTimeout(code[, delay]);
```
1）返回的timeoutID不一样
2）code值不一样，一个传入1一个传入2；注意code是delay毫秒之后编译和执行的字符串，不推荐，跟eval一样有安全风险；
3）执行时间不一样，虽然都没有设置delay，默认0ms，但是都要放到任务队列排队等待被执行；有先后顺序；

# 浏览器中的事件循环
## 1.机制如下：
浏览器的事件循环，是在渲染进程中的；
执行一个宏任务，栈中没有就从事件队列中获取；
执行过程中如果遇到微任务，就添加到微任务的队列中；
当前这个宏任务执行完毕后，立即执行当前微任务队列的所有微任务；
当前宏任务执行完毕，GUI线程接管渲染；
渲染完毕后，JS线程继续接管，开始下一个宏任务；

简化就两步：执行一个宏任务，执行完它对于的所有微任务；
{% asset_img ClassName 4.png %}

## 2.浏览器渲染进程有三个异步队列
- 宏任务macrotask/Tasks 
- 微任务Microtasks/Jobs
- Animation callbacks：requestAnimationFrame也属于异步执行的方法，但该方法既不属于宏任务，也不属于微任务。

（1）宏任务队列，每次循环只执行一个。
设置 2 个相同时间的 timeout，两个并不会一起执行，依然是分批的。
（2）微任务队列，每次循环会把队列全部执行完才继续。因此如果任务本身又新增 Microtasks，也会一直执行下去。所以下面的例子才会产生阻塞。
```js
function callback() {
  Promise.resolve().then(callback)
}
callback();
```
（3）Animation callbacks队列，每次循环执行队列里的全部任务，连续调用两句 requestAnimationFrame，会在同一次事件循环执行；但是任务本身又新增 Animation callback 是放到下一个循环执行，不会阻塞；
（4）例题：
```js
function test1() {
  test1();
}
test1();
function test2() {
  setTimeout(test2);
}
test2();
function test3() {
  Promise.resolve().then(test3);
}
test3();
```
1）test1会导致执行栈溢出，因为所有的代码都在同步执行栈中，最大栈深度25000，溢出；
2）test2，可以正常运行，因为把任务移到了宏任务队列中，没有阻塞主渲染线程；
3）test3可以运行，但是会造成页面卡顿，因为微任务队列自身创建微任务，会不停创建执行、创建执行，虽然不会爆栈，但是阻塞了主线程，页面卡顿严重；

## 3.promise相关的经典面试题
### （1）promise.then要等到resolve之后加入当前宏任务后面的微任务中；
```js
console.log('1');
setTimeout(() => {
    console.log("2")
    Promise.resolve().then(() => {
        console.log("3")
    })
}, 0);
new Promise((resolve, reject) => {
    console.log("4")
    setTimeout(() => {
        console.log("5")
        resolve("6");
    }, 0);
}).then((res) => {
    console.log("7");
    setTimeout(() => {
        console.log(res)
    }, 0);
}).then(() => {
    console.log("8");
}).then(() => {
    console.log("9");
});
```

- 第一轮：宏任务1, 4；   微任务：空
- 第二轮：宏任务2；      微任务：3
- 第三轮：宏任务5，      微任务：resolve了，把对应微任务加入~~7、8、9
- 第四轮：6
结果依次输出：1 4 2 3 5 7 8 9 6

### （2）promise.then 中 return Promise.resolve ，会产生类似两轮的微任务
4的地方产生两轮微任务，所以3、7这一轮完了要再等两轮，再8、9之后输出
输出结果：1、5、2、6、3、7、8、9、4、10
```js
Promise.resolve()
.then(() => {
    console.log(1);
})
.then(() => {
    console.log(2);
})
.then(() => {
    console.log(3);
    return Promise.resolve(4);
})
.then((res) => {
    console.log(res);
})

Promise.resolve()
.then(() => {
    console.log(5);
})
.then(() => {
    console.log(6);
})
.then(() => {
    console.log(7);
})
.then(() => {
    console.log(8);
})
.then(() => {
    console.log(9);
})
.then(() => {
    console.log(10);
})
```

具体V8的底层原理，可以看知乎这一个问题
https://www.zhihu.com/question/453677175/answer/1841325386

# nodejs中的event loop
## 一.nodejs中事件循环和浏览器的异同
### 1.底层不同
一个基于浏览器；一个基于libuv库；
放一个nodejs的系统架构图
{% asset_img ClassName 5.png %}

### 2.宏任务微任务的执行机制不同
（1）node11之前
1）执行完一个阶段所有同类型的宏任务
2）执行完nextTick队列里面的内容
3）然后执行完微任务队列的内容，
（2）Node11之后
宏任务和微任务的执行结果，跟浏览器一致了；
- 执行首个宏任务 -> 执行这个宏任务中的所有微任务 -> event loop执行完毕，执行下一个eventloop

实际底层的原理不一样，node中的流程如下：
{% asset_img ClassName 6.png %}

- Node.js中可以理解为4种宏任务队列和2种微任务队列，但是执行宏任务时有6个阶段。
4种宏任务队列：setTimeout 、setInterval 、setImmediate、I/O包括文件和网络
2种微任务队列：process.nextTick、 new Promise().then 回调
- Node.js中，先执行全局Script代码
- 执行完同步代码后，先从微任务队列Next Tick Queue中取出所有的任务放入调用栈中执行
- 再从微任务队列Other Microtask Queue依次取出所有的任务放入调用栈中执行。
- 然后开始宏任务的6个阶段，每个阶段都把宏任务队列中所有任务取出来执行， 在执行下一阶段的宏任务，每一个宏任务完成执行完该宏任务的微任务队列，以此来构成事件循环。

### 3.相同点
（1）事件循环event loop的目的：处理同步和异步事件的一种事件调度机制；
（2）循环是没有终点的，只要进程在，就会有新任务，就会去执行；

## 二.事件循环的六个阶段
官网的图
{% asset_img ClassName 7.png %}
{% asset_img ClassName 8.png %}

### 1.timers定时器：
（1）本阶段执行 setTimeout() 和 setInterval() 的回调函数。
（2）事件循环的起点：
node服务器启动、setTimeout() 和 setInterval() 的回调函数、I/O回调函数；

### 2.pending callbacks：
本阶段执行某些系统操作（比如TCP错误类型）的回调函数；

### 3.idle, prepare：仅系统内部使用。

### 4.poll 轮询：
（1）主要处理异步 I/O 的回调，以及除了timers之外几乎所有的回调函数；其余情况 node会在适当时候在此处阻塞。
（2）异步I/O分为：网络I/O和文件I/O；

poll 是一个至关重要的阶段，这一阶段中，系统会做两件事情
1.回到 timer 阶段执行回调
2.执行 I/O 回调
（1）在进入该阶段时如果<font color="#FF0000"> 没有 </font>设定 timer 的话，会发生以下两件事情
- 如果 poll 队列<font color="#FF0000"> 不为空 </font>，会遍历回调队列并同步执行，直到队列为空或者达到系统限制
- 如果 poll 队列<font color="#FF0000"> 为空 </font>时，会有两件事发生
  - 如果有 setImmediate 回调需要执行，poll 阶段会停止并且进入到 check 阶段执行回调
  - 如果没有 setImmediate 回调需要执行，会等待回调被加入到队列中并立即执行回调，这里同样会有个超时时间设置防止一直等待下去
（2）如果<font color="#FF0000"> 设置了 </font> timer 的话且 poll 队列为空，则会判断是否有 timer 超时，如果有的话会回到 timer 阶段执行回调。

### 5.check 检测：
（）setImmediate() 回调函数在这里执行；
（）注意并不是马上执行，而是当事件循环poll中没有新的事件处理时才执行这部分；

### 6.close callbacks 
执行一些关闭的回调函数，如：socket.on('close', …)。

## 三.process.nextTick
这个函数其实是独立于 Event Loop 之外的，它有一个自己的队列，当每个阶段完成后，如果存在 nextTick 队列，就会清空队列中的所有回调函数，并且优先于其他 microtask 执行

## 四.nodejs事件循环的一些经典面试题
### 1.nodejs中setTimeout 和 setImmediate
二者非常相似，区别主要在于调用时机不同。
（1）setImmediate 设计在poll阶段完成时执行，即第五个check阶段；
（2）setTimeout 设计在poll阶段为空闲时，且设定时间到达后执行，但它在第一个timer阶段执行
```js
setTimeout(function timeout () {
  console.log('timeout');
},0);
setImmediate(function immediate () {
  console.log('immediate');
});
```
（1）对于以上代码来说，setTimeout 可能执行在前，也可能执行在后。
（2）首先 setTimeout(fn, 0) === setTimeout(fn, 1)，这是由源码决定的；然后进入事件循环也是需要成本的，如果准备时间花费大于 1ms 的时间，那么在 timer 阶段就会直接执行 setTimeout 回调
（3）如果准备时间花费小于 1ms，那么就是 setImmediate 回调先执行了

### 2.上面的代码如果放到fs.readFile的回调中
结果就是固定的,先是immediate再是timeout
```js
const fs = require('fs');
fs.readFile('./testReadFile.js', { encoding: 'utf-8' }, (err, data) => {
  if (err) throw err;
  console.log('read file success');
  setTimeout(function timeout() {
    console.log('timeout');
  }, 0);
  setImmediate(function immediate() {
    console.log('immediate');
  });
});
```
因为读完文件就是进入到了I/O阶段，Poll队列为空，有setImmediate，poll 阶段会停止并且进入到 check 阶段执行回调。

### 3.同一轮事件循环，优先把微任务队列清空再执行宏任务队列
```js 
const fs = require('fs');
console.log('script start');
/// 将会在 poll 阶段执行
fs.readFile('./testReadFile.js', { encoding: 'utf-8' }, (err, data) => {
  if (err) throw err;
  console.log('read file success');
});
setImmediate(() => {
  console.log('setImmediate');
});
setTimeout(() => {
  console.log('setTimeout');
  fs.readFile('./testReadFile.js', { encoding: 'utf-8' }, (err, data) => {
    if (err) throw err;
    console.log('read file success 2');
  });
}, 0);
/// 该部分将会在首次事件循环中执行
Promise.resolve()
  .then(() => {
    console.log('promise1');
  })
  .then(() => {
    console.log('promise2');
  })
  .then(() => {
    console.log('promise3');
  });
Promise.resolve()
  .then(() => {
    console.log('promise4');
  })
  .then(() => {
    console.log('promise5');
  })
  .then(() => {
    console.log('promise6');
  });

process.nextTick(() => {
  console.log('nextTick callback');
});
// 首次事件循环执行
console.log('script end');
```

（1）主代码块输出script start、 script end
（2）微任务： promise和nextTick 全都放到poll中，一次性全部执行完，nextTick优先级高，所以先打印
（3）setTimeout 1ms执行完加到 poll队列，去执行；里面的fs.readfile 2放到下一轮；
（4）poll队列为空，去执行 setImmediate
（5）文件读取完成 加入poll队列，输出 read file success 和 read file success 2
结果：
// script start
// script end
// nextTick callback
// promise1
// promise4
// promise2
// promise5
// promise3
// promise6
// setTimeout
// setImmediate
// read file success
// read file success 2

#### 4.主线程会被阻塞
```js
const fs = require('fs');

setTimeout(() => {
  // 新的事件循环的起点
  console.log('1');
  sleep(3000);
  console.log('sleep 3s');
}, 0); // 换成 50ms 结果不一样

/// 将会在 poll 阶段执行
fs.readFile('./testReadFile.js', { encoding: 'utf-8' }, (err, data) => {
  if (err) throw err;
  console.log('read file success');
});

console.log('2');

/// 函数实现，参数 n 单位 毫秒 ；
function sleep(n) {
  var start = new Date().getTime();
  while (true) {
    if (new Date().getTime() - start > n) {
      // 使用  break  实现；
      break;
    }
  }
}
```

（1）setTimeout时间设置0的结果
2
1
sleep 3s
read file success
（2）setTimeout时间设置50ms的结果
setTimeout 50ms 的结果
2
read file success
1
sleep 3s

#### 5.Nodejs是单线程还是多线程？
（1）主线程是单线程执行；
（2）但是node存在多线程执行，包括 setTimeout、异步I/O如网络I/O和文件I/O；
（3）还有其他线程，垃圾回收、内存优化等等；

--END--

同时欢迎关注我的个人微信公众号：
{% img https://www.xuanbiyijue.com//img/%E5%85%AC%E4%BC%97%E5%8F%B7%E4%BA%8C%E7%BB%B4%E7%A0%81.jpg 300 300 %}