---
title: Parcel Vs Webpack
categories:
  - 前端工程化与持续构建
tags:
  - Parcel
  - Webpack
date: 2018-02-02 21:02:15
---


**原文链接**   {% link segmentfault吴浩麟 https://segmentfault.com/a/1190000012612891 %}



### Parcel 让人眼前一亮
在用了很久 Webpack 后用 Parcel 的感觉就像用了很久 Android 机后用 iPhone，不用再去操心细节和配置，大多数时候 Parcel 刚刚够用而且用的很舒服。

用 Parcel 去完成项目的要求，只是专心去写项目页面所必须的代码，Parcel 智能快速的帮我构建出了能正常运行的结果。

以下是Parcel让我心动的点：
{% blockquote %}
· Parcel 能做到无配置完成以上项目构建要求；
· Parcel 内置了常见场景的构建方案及其依赖，无需再安装各种依赖；
· Parcel 能以 HTML 为入口，自动检测和打包依赖资源；
· Parcel 默认支持模块热替换，真正的开箱即用；
{% endblockquote %}

而反观 Webpack，比 Parcel 要麻烦很多：
{% blockquote %}
· 需要写一堆配置；
· 需要再安装一堆依赖；
· 不能简单的自动生成 HTML；
{% endblockquote %}


### Parcel 还需要时间去打磨

通过实际项目实践，发现 Parcel 目前有如下明显的缺点：
{% blockquote %}
· 不支持 SourceMap ：在开发模式下，Parcel 也不会输出 SourceMap，目前只能去调试可读性极低的代码；
· 不支持剔除无效代码 ( TreeShaking )：很多时候我们只用到了库中的一个函数，结果 Parcel 把整个库都打包了进来；
· 一些依赖会 让Parcel 出错：当你的项目依赖了一些 Npm 上的模块时，有些 Npm 模块会让 Parcel 运行错误；
{% endblockquote %}


### Parcel 需要为零配置付出代价

零配置其实是把各种常见的场景做为默认值来实现的，这虽然能节省很多工作量，快速上手，但这同时会带来一些问题：

{% blockquote %}
· 不守规矩的 node_module ：有些依赖的库在发布到 Npm 上时可能不小心把.babelrc postcss.config.js tsconfig.json这些配置文件也一起发布上去了
{% endblockquote %}

由于目前 Parcel 只要在目录中发现这些配置文件就会认为该项目中的代码需要被处理。例如 mini-store 这个库中就把.babelrc文件发布到了 Npm 上，项目依赖的本来是 lib 中已经编译成了 ES5 的 JS 代码了，但 Parcel 还会去用 Babel 处理一遍。

Npm官方并没有规定发布到 Npm 上的包需要符合哪些规范，这会让 Parcel 很为难。

#### 不够灵活的配置：
零配置的 Parcel 关闭了很多配置项，在一些需要的配置的场景下无法改变。比如：

{% blockquote %}
· 无法控制对部分文件的特殊处理，以实现诸如按需加载这样的需求；
· 无法控制输出文件名的 Hash 值和名称；
· 无法控制构建输出目录结构；
· 无法映射路径以缩短导入语句；
· HTTP 开发服务器不支持 HistoryApi ；
{% endblockquote %}


### Parcel 使用场景受限

目前 Parcel 只能用来构建用于运行在浏览器中的网页，这也是他的出发点和专注点。

在软件行业不可能存在即使用简单又可以适应各种场景的方案，就算所谓的人工智能也许能解决这个问题，但人工智能不能保证 100% 的正确性。

反观 Webpack 除了用于构建网页，还可以做：

{% blockquote %}
· 打包发布到 Npm 上的库
· 构建 Node.js 应用 ( 同构应用 )
· 构建 Electron 应用
· 构建离线应用 ( ServiceWorkers )
{% endblockquote %}


### 构建速度和输出文件大小对比

Parcel 构建速度快，但 Parcel 输出文件大

导致 Parcel 构建速度快的原因和 iOS 比 Android 用起来更流畅的原因类似：

{% blockquote %}
· Parcel 因为一体化内置，所以集成和优化的更好，而 Webpack 通过插件和 Loader 机制去让第三方扩展这会拉低性能；
· Parcel 内置多进程并行构建，而 Webpack 默认是单进程构建 ( Webpack 可配置支持多进程 )；
{% endblockquote %}

导致 Parcel 输出 JS 文件大的原因在于：
{% blockquote %}
· 不支持 TreeShaking
· 构建出的 JS 中出现了所有文件的名称
{% endblockquote %}


### 总结

现阶段的 Parcel 就像 beta 版的 iPhone，看上去很美好但还不能用于生成环境，如果你现在就把 Parcel 用于生成环境，相信我你一定会踩很多坑。

踩坑不要紧，要命的是无法在网上找到解决方法以快速解决问题。

我不是不鼓励大家使用 Parcel，历史总需要先驱去推动，就像乔布斯义无反顾的引领了一个时代，我们也需要去实践 Parcel，坑都是一个个填平的，所以我鼓励大家在一些个人小项目中使用 Parcel。

如果 Parcel 能解决上面提到的这些问题，我会毫不犹豫的在我的下一个项目中使用他。



