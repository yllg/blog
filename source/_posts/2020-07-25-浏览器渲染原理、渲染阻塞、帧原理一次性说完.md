---
title: 浏览器渲染原理、渲染阻塞、帧原理一次性说完
categories:
  - 前端性能优化与工程化
  - null
tags:
  - null
  - null
date: 2020-07-25 23:11:49
top:
---

# 一.chrome架构
## 1.打开一个页面，chrome启动<font color="#FF0000"> 4个 </font>进程；
准确的说是，<font color="#FF0000"> 最少四个 </font>
主进程+网络进程+GPU进程+渲染进程；
开启了插件还有更多的插件进程；

## 2.最新的 Chrome 浏览器的进程包括：五种
### （1）1 个浏览器（Browser）主进程
界面显示、用户交互、子进程管理，存储功能；
### （2）1 个网络（NetWork）进程：
网络资源加载；
### （3）1 个 GPU 进程：
绘制UI界面；
### （4）多个渲染进程
将HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，
渲染引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，
默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。
出于安全考虑，渲染进程都是运行在沙箱模式下，不能获取系统权限对硬盘进行读写等；

{% blockquote %}
注意：
1.<font color="#FF0000"> 同一站点 </font>的tab页共用一个渲染进程
新页面会复用父页面的渲染进程。
官方把这个默认策略叫 process-per-site-instance。
“同一站点”跟同源策略的定义一样，协议、域名、端口都要相同；

2.渲染进程包含很多个子线程：
有合成线程（Compositor），合成图块栅格化线程（Compositor Tile Worker），和主线程。
{% endblockquote %}


### （5）多个插件进程
插件易崩溃，做一个隔离，免得影响整个页面；

## 3.目前架构的两个问题
（1）更高的资源占用。
（2）更复杂的体系结构；
## 4.未来的发展
（）“面向服务的架构”（Services Oriented Architecture，简称 SOA）
学习操作系统的架构，原来的各种模块会被重构成独立的服务（Service），每个在独立的进程中运行，访问服务（Service）必须使用定义好的接口，通过 IPC 来通信，从而构建一个更内聚、松耦合、易于维护和扩展的系统

# 二.一个经典的问题，浏览器输入URL发生了什么？
## 一.导航流程
用户输入 到 开始渲染 的整个过程

### 1.用户输入
【主进程处理】
（1）判断输入是否符合URL规则
不符合判断是搜索内容的关键词，用默认<font color="#FF0000"> 搜索引擎 </font>搜索；
符合的话，加上协议拼成完成URL，浏览器进程会通过进程间通信（IPC）把 URL 请求转发给网络进程；
（2）有一个beforeunload 事件，让用户确认是否离开；

### 2.构建请求：
【网络进程处理】
构建请求行，包括请求方法，URI，http协议
比如：GET  /index.html HTTP1.1

### 3.查找缓存
没有缓存，才真正发起请求；
### 4.准备IP和端口
IP~DNS解析
端口默认，http是80 https是443
### 5.如果是HTTPS协议
要进行TLS连接；

### 6.数据链路层ARP地址解析协议
根据IP找到Mac地址；
### 7.等待TCP队列
同一个域名同时最多只能建立 6 个 TCP 连接
当前请求书大于6就要等待，小于6进入下一步；
### 8.TCP连接
建立连接3次握手4次挥手
### 9.HTTP请求
（1）请求行
包括：请求方法、请求 URI（Uniform Resource Identifier），HTTP 版本协议
POST请求，数据放在请求体传给服务器；
（2）请求头：
包含了浏览器所使用的操作系统、浏览器内核等信息，当前请求域名信息、浏览器 Cookie 信息等等
### 10.HTTP响应
（1）响应行，包括：协议版本和状态码
（2）响应头，包括：服务器生成返回数据的时间、返回的数据类型（JSON、HTML、流媒体等类型），以及服务器要在客户端保存的 Cookie 等信息
（3）响应体，我们请求的真正内容；
### 11.重定向
如果状态码是301永久重定向或302临时重定向，读取响应头的 Location 字段里面读取重定向的地址，重新发请求一切从头来；
### 12.根据响应头的 Content-Type，判断响应数据的类型
application/octet-stream交给下载管理器下载
text/html 才是渲染页面；
### 13.提交文档阶段
浏览器进程接收到网络进程的响应头数据之后，便向渲染进程发起“提交文档”的消息；
渲染进程接收到消息后，会和网络进程建立传输数据的“管道”；
等文档数据传输完成之后，渲染进程会返回“确认提交”的消息给浏览器进程；
浏览器进程在收到后，会更新浏览器界面状态，包括安全状态、地址栏 URL、前进后退的历史状态，更新 Web 页

## 二．渲染流程
【渲染进程处理】
### 1.构建 DOM 树
将HTML 转换为浏览器能够理解的结构——DOM 树
（1）HTML词法、语法的解析、
词法分析：把字符流初步解析成我们可理解的"词"，学名叫token。
语法分析：把开始结束标签配对、属性赋值好、父子关系连接好、构成dom树。
（2）请求js，css

### 2.样式计算（Recalculate Style）
#### 2-1. 把 CSS 转换为浏览器能够理解的结构—styleSheets；
#### 2-2. 转换样式表中的属性值，使其标准化；
比如2em、blue、bold
#### 2-3. 计算出 DOM 树中每个节点的具体样式
2-3-1. CSS 继承，包含父节点的样式；
2-3-2.样式层叠的规则
!important 无限高 > 内联 1000> id 100> class 10> tag > 继承 >浏览器默认

### 3.布局阶段
#### 3-1. 创建布局树Layout tree
构建一棵只包含可见元素布局树，比如<font color="#FF0000"> head标签，不可见元素 </font>都不包含；
#### 3-2. 布局计算
有个不合理的地方，布局阶段并没有清晰地将输入内容和输出内容区分开来。
针对这个问题，Chrome 团队正在重构布局代码，下一代布局系统叫 LayoutNG，试图更清晰地分离输入和输出，

### 4.分层
#### （1）图层树（LayerTree）
页面中有复杂效果，如 3D 变换、页面滚动，或者使用 z-indexing 做 z 轴排序等，渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树。
#### （2）图层树和布局树的关系
布局树的每一个节点自己没有单独的图层，就属于父节点的图层，反正所有的节点都会直接或者间接地从属于一个层，
#### （3）哪些节点会创建新的图层
1）拥有<font color="#FF0000"> 层叠上下文属性 </font>的元素会被提升为单独的一层。
比如：明确定位属性position：fixed、定义透明属性opacity、使用 CSS 滤镜filter的元素、z-index
2）需要<font color="#FF0000"> 剪裁（clip） </font>的地方也会被创建为图层。
比如div内容的文字超出div范围，会被裁剪，渲染引擎单独为文字部分单独创建一个层；
如果出现滚动条，滚动条也会被提升为单独的层；

### 5.图层绘制
图层的绘制拆分成很多小的绘制指令，然后再把这些指令按照顺序组成一个待绘制列表；
可以在开发者工具的Layers点击document的<font color="#FF0000"> profiler </font> 查看到绘制列表；

### 6.合成线程进行分块
（1）主线程会把该绘制列表提交（commit）给合成线程，进行真正的绘制；
（2）合成线程会将图层划分为<font color="#FF0000"> 图块（tile）</font>，这些图块的大小通常是 256x256 或者 512x512，

### 7.栅格化
（1）栅格化，是指将图块转换为<font color="#FF0000"> 位图 </font>。图块是栅格化执行的最小单位。渲染进程维护了一个栅格化的线程池，所有的图块栅格化都是在线程池内执行的；
（2）按照<font color="#FF0000"> 视口附近 </font>的图块来优先生成位图;
（3）栅格化过程都会使用 GPU 来加速生成，使用 GPU 生成位图的过程叫<font color="#FF0000"> 快速栅格化 </font>，或者 GPU 栅格化，生成的位图被保存在 GPU 内存中；这是跨进程操作，渲染进程到GPU进程；

{% asset_img ClassName 1.png %}

### 8.合成和显示
（1）一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令——“DrawQuad”，然后将该命令提交给浏览器进程。
（2）浏览器进程里面有一个叫 viz 的组件，用来接收合成线程发过来的 DrawQuad 命令，然后根据 DrawQuad 命令，将其页面内容绘制到内存中，最后再将内存显示在屏幕上。
{% asset_img ClassName 2.png %}

## 三.重排重绘
上面整个渲染过程：
DOM、Style、layout、layer、paint、tiles、raster、draw quad、display、
### (1)重排：
修改几何属性，影响layout后面全部；
### (2)重绘：
修改绘制属性，影响paint之后；
### (3)合成：
1.修改不要布局不要绘制的属性，只影响后续合成操作 tiles后面；性能好；
2.最常见的就是 CSS3 硬件加速（GPU加速），四点
transform: translateZ(0)、opacity、filters、will-change
Will-change提前告诉浏览器元素会发生什么变化；

# 三.浏览器加载中会发出哪些事件，执行顺序
## 1.document readystatechange事件
（1）readyState 属性
描述了当前文档的加载状态，在整个加载过程中 document.readyState会不断变化，每次变化都会触发readystatechange事件。
（2）readyState 有以下状态：
uninitialized - 还未开始载入；
loading - 载入中；
interactive - 互动文档已经完成加载，文档已被解析，但是诸如图像，样式表和框架之类的子资源仍在加载，文档与用户可以开始交互；
complete - 载入完成

## 2.DOMContentLoaded事件
（1）DOMContentLoaded事件是docoment对象上的事件。指的是DOM已经加载完毕。
（2）DOM树渲染完成时触发DOMContentLoaded事件，此时外部资源可能并未加载完成。

## 3.window.load事件
load事件是window对象上的事件。指的是网页资源已经加载完毕（包括但不限于DOM、图片、音频、脚本、插件资源以及CSS）
<font color="#FF0000"> 所有的资源 </font>全部加载完成会触发window 的 load事件。

# 四.渲染阻塞相关的问题
## 1.DOM的解析
html文档<font color="#FF0000"> 边加载边解析 </font>的；网络进程和渲染进程之间会建立一个共享数据的管道，网络进程接收到数据实时传递给渲染进程，渲染进程的 HTML 解析器，它会动态接收字节流，并将其解析为 DOM

## 2.字节流转换为 DOM 需要三个阶段
（0）字节流转 tokens ，tokens 生成节点node，最后生成DOM；
最关键是第一点；
（1）通过分词器将字节流转换为 Token。
Tag Token 又分 StartTag ， EndTag，文本token；
分别对应下图的蓝、红、绿；
{% asset_img ClassName 3.png %}

靠一个<font color="#FF0000"> 栈结构 </font>来维护；
注意，文本 Token 是不需要压入到栈
{% asset_img ClassName 4.png %}

## 3.JS影响
### （1）script脚本
会暂停DOM解析
因为接下来的 JavaScript 可能要修改当前已经生成的 DOM 结构
### （2）引入外部JS文件
会阻塞DOM解析，需要等待下载完成才行；
浏览器有个优化，渲染进程有个预解析线程，提前下载JS和css文件
所以不用操作dom的js文件，可以设置为异步加载，<font color="#FF0000"> async和defer </font>，async加载完立即执行还是会阻塞渲染，最好用defer；
### （3）JS代码上面的CSS文件
因为不知道JS是否要处理CSS，所以不管怎样都会等待CSS文件加载好；再继续执行JS；
### （4）script放在页面底部的影响
不影响DOM解析，但会影响渲染；

## 4.CSS加载
### （1）CSS加载
CSS代码下面如果没有script代码段，就不会影响DOMContentLoaded；
如果有JS代码，会等待CSS加载完成，会阻塞DOM解析；
### （2）含有 JavaScript 文件和 CSS 文件页面的渲染流水线
预解析器同时发出两个文件请求，不管 CSS 文件和 JavaScript 文件谁先到达，都要先等到 CSS 文件下载完成并生成 CSSOM，然后再执行 JavaScript 脚本，最后再继续构建 DOM，构建布局树，绘制页面
{% asset_img ClassName 5.png %}


# 五.浏览器的帧原理剖析
浏览器每一帧，简单理解为一次事件循环，一图胜千言
{% asset_img ClassName 6.png %}

## 一．每一帧只要涉及两个进程
### 1.渲染进程。
（1）可以有多个；默认每个tab一个，同一站点的tab共父元素的一个渲染进程；
（2）包裹标签页的容器。包含了多个线程，这些线程一起负责了页面显示到屏幕上的各个方面。
（3）有合成线程（Compositor），合成图块栅格化线程（Compositor Tile Worker），和主线程。
### 2.GPU 进程。
这是一个单一的进程，为所有标签页和浏览器周边进程服务。
当帧被提交时，GPU 进程会将分为图块的位图和其他数据（比如四边形顶点和矩阵）上传到 GPU 中，真正将像素显示到屏幕上。GPU 进程只有一个的线程，叫 GPU 线程。

## 二．具体过程
### 1.渲染进程的合成线程（Compositor Thread）
（1）在显卡中有一块叫着前缓冲区的地方，存放着显示器要显示的图像，显示器会按照一定的频率来读取这块前缓冲区，并将前缓冲区中的图像显示在显示器上，不同的显示器读取的频率是不同的，通常情况下是 <font color="#FF0000"> 60HZ </font>，也就是说显示器会每间隔 1/60 秒就读取一次前缓冲区。
（2）当显示器将一帧画面绘制完成后，并在准备读取下一帧之前，显示器会发出一个垂直同步信号（vertical synchronization），简称 <font color="#FF0000"> VSync </font>。
（3）操作系统告知浏览器刷新一帧图像的信号，合成进程是最先被告知垂直同步事件vsync event，。
### 2.处理事件输入
从合成线程将输入的数据，传递到主线程的事件处理函数。
### 3.RAF~requestAnimation 调用
RAF在每一帧的开始，确切的说是raf的回调任务会在每一帧的开始执行；
### 4.上面的渲染过程
DOM、sytle、layout、layers、paint、tiles、raster、draw quad、display
### 5.帧结束还有时间调用requestIdleCallback 
理想的一帧时间是 16ms (1000ms / 60)，如果浏览器处理完上述的任务(布局和绘制之后)，还有盈余时间，浏览器就会调用 requestIdleCallback 的回调


演示地址: [演示地址](https://yllg.github.io/ZWJ/)
GitHub: [GitHub链接](https://github.com/yllg/ZWJ)
欢迎小伙伴们star 💗❤️💖~~

同时欢迎关注我的个人微信公众号：
{% img https://www.xuanbiyijue.com//img/%E5%85%AC%E4%BC%97%E5%8F%B7%E4%BA%8C%E7%BB%B4%E7%A0%81.jpg 300 300 %}