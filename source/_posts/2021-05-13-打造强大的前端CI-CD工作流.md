---
title: 打造强大的前端CI/CD工作流
categories:
  - 前端工程化与持续构建
  - null
tags:
  - null
  - null
date: 2021-05-13 08:22:34
top:
---

# 目录

- 基于 Jenkins 的 CI/CD 工作流程
- 基于 gitlab 的 CI/CD 工作流程

# 一.基于 Jenkins 的 CI/CD 工作流程

目标：
本地项目发起一个 git 提交，剩下的单元测试，打包构建，代码部署，邮件提醒等全部自动化完成。

Jenkins 是什么？
Jenkins 是一款业界流行的开源持续集成工具，广泛用于项目开发，具有自动化构建、测试和部署等功能。

## 1.准备工作

先准备一个项目，vue、react，或着其他技术栈都行

建立这个项目的远端 git 仓库，并把本地代码提交上去。github、码云等都可以

准备一台能外网访问的服务器，非要用你自己的电脑当服务器也可以，保证外网可访问即可。我这里用的是阿里云 CentOS 7.3,服务器上配好 Java 环境。

## 2.Jenkins 的安装与启动

linux 下安装 Jenkins 就不再赘述了

## 3.Jenkins 初始化

jenkins 的默认端口是 8080,启动成功后在浏览器打开。

进入后会让我们输管理员密码，打开网页上提示路径下的文件，复制密码粘贴输入即可。

然后会让安装需要的插件，此处选默认即可，等待安装完成。

创建一个管理员账户。

上面都完成后会看到这个界面。

{% asset_img ClassName 1.webp %}

## 4.创建任务

点击“创建一个新任务”

选择自由风格的软件项目，并起一个名字
{% asset_img ClassName 2.webp %}

至此，基础准备工作已经完成，我们在服务器上安装了 Jenkins 并启动，然后进行了初始化配置，建立了一个新任务。接下来我们开始配置我们需要的功能。

## 5.实现 git 钩子功能

首先我们要实现一个 git 钩子功能，就是我们向 github/码云等远程仓库 push 我们的代码时，jenkins 能知道我们提交了代码，这是自动构建自动部署的前提。

钩子的实现原理：
在远端仓库上配置一个 Jenkins 服务器的接口地址，当本地向远端仓库发起 push 时，远端仓库会向配置的 Jenkins 服务器的接口地址发起一个带参数的请求，jenkins 收到后开始工作。

打开刚创建的任务，选择配置，添加远程仓库地址，配置登录名、密码及分支。

{% asset_img ClassName 3.jpg %}

## 6.安装 Generic Webhook Trigger Plugin 插件

（系统管理-插件管理-搜索 Generic Webhook Trigger Plugin）如果可选插件列表为空，点击高级标签页，替换升级站点的 URL 为：http://mirror.xmission.com/jenkins/updates/update-center.json并且点击提交和立即获取。

## 7.添加触发器

第 2 步安装的触发器插件功能很强大，可以根据不同的触发参数触发不同的构建操作，
比如我向远程仓库提交的是 master 分支的代码，就执行代码部署工作，
我向远程仓库提交的是某个 feature 分支，就执行单元测试，单元测试通过后合并至 dev 分支。
灵活性很高，可以自定义配置适合自己公司的方案，这里方便演示我们不做任何条件判断，只要有提交就触发。在任务配置里勾选 Generic Webhook Trigger 即可

{% asset_img ClassName 4.webp %}

## 8.仓库配置钩子

此处以码云为例，github 的配置基本一致，进入码云项目主页后，点击管理-webhooks-添加，会跳出一个这样的框来。

{% asset_img ClassName 5.webp %}

URL 格式为 http://<User ID>:<API Token>@<Jenkins IP 地址>:端口/generic-webhook-trigger/invoke

userid 和 api token 在 jenkins 的系统管理-管理用户-admin-设置里

Jenkins IP 地址和端口是你部署 jenkins 服务器的 ip 地址，端口号没改过的话就是 8080。

密码填你和上面 userid 对应的密码，我这里是 root。

下面的几个选项是你在仓库执行什么操作的时候触发钩子，这里默认用 push。

点击提交完成配置。

测试钩子
{% asset_img ClassName 6.jpg %}
点击测试，如果配置是成功的，你的 Jenkins 左侧栏构建执行状态里将会出现一个任务。

{% asset_img ClassName 7.webp %}

另外，你也可以试下本地提交代码，提交代码后，jenkins 也会开始一个任务,目前我们没有配置任务开始后让它做什么，所以默认它只会在你提交新代码后，将新代码拉取到 jenkins 服务器上。
到此为止，git 钩子我们配置完成。

## 9.实现自动化构建

git push 触发钩子后，jenkins 就要开始工作了，自动化的构建任务可以有很多种，比如说安装升级依赖包，单元测试，e2e 测试，压缩静态资源，批量重命名等等，无论是 npm script 还是 webpack，gulp 之类的工作流，你之前在本地能做的，在这里同样可以做。

作为演示，这里只演示三个基本常用的工作流程，安装依赖包->单元测试->打包，也就是下面这三个命令。

{% blockquote %}

- npm install
- npm run test
- npm run build
  {% endblockquote %}

首先，和本地运行 npm script 一样，我们要想在 jenkins 里面执行 npm 命令，先要在 jenkins 里面配置 node 的环境
可以通过配置环境变量的方式引入 node，也可以通过安装插件的方式，这里使用了插件的方式，安装一下 nvm wrapper 这个插件。

打开刚刚的 jenkins 任务，点击配置里面的“构建环境”，勾选这个，并指定一个 node 版本。

{% asset_img ClassName 8.webp %}

点击“构建”，把要执行的命令输进去，多个命令使用&&分开，保存；

{% asset_img ClassName 9.webp %}

此时本地修改一下代码 push 测试一下（也可以点击立即构建测试），点击本次触发的那个任务，选择控制台输出，将会看到 Jenkins 在云端执行的过程。

{% asset_img ClassName 10.webp %}

命令行最后一行是 Finished 状态;
如果是 SUCCESS（蓝色）则证明执行的任务都顺利进行
是 FAILURE（红色）则证明中间有重大错误导致任务失败
UNSTABLE（黄色）代表有虽然有些小问题，但不阻碍任务进行
黄色或者红色可以去命令行看下错误输出，看下哪里出了问题。

{% asset_img ClassName 11.webp %}

如果上一步是 SUCCESS，点击项目的工作空间，将会发现多了 dist 和 node_modules 两个文件夹。

至此，我们已经搭建了一个简易的构建工作流程，构建完成了，我们需要自动化部署。

## 10.实现自动化部署

自动化部署可能是我们最需要的功能了，公司就一台服务器，我们可以使用人工部署的方式，但是如果公司有 100 台服务器呢，人工部署就有些吃力了，而且一旦线上出了问题，回滚也很麻烦。所以这一节实现一下自动部署的功能。

1.首先，先在 Jenkins 上装一个插件 Publish Over SSH，我们将通过这个工具实现服务器部署功能

2.在要部署代码的服务器上创建一个文件夹用于接收 Jenkins 传过来的代码，我在服务器上建了一个 testjenkins 的文件夹。

3.Jenkins 想要往服务器上部署代码必须登录服务器才可以，这里有两种登录验证方式，一种是 ssh 验证，一种是密码验证，就像你自己登录你的服务器，你可以使用 ssh 免密登录，也可以每次输密码登录，系统管理-系统设置里找到 Publish over SSH 这一项。

重点参数说明：

```
 Passphrase：密码（key的密码，没设置就是空）
 Path to key：key文件（私钥）的路径
 Key：将私钥复制到这个框中(path to key和key写一个即可)

 SSH Servers的配置：
 SSH Server Name：标识的名字（随便你取什么）
 Hostname：需要连接ssh的主机名或ip地址（建议ip）
 Username：用户名
 Remote Directory：远程目录（上面第二步建的testjenkins文件夹的路径）

 高级配置：
 Use password authentication, or use a different key：勾选这个可以使用密码登录，不想配ssh的可以用这个先试试
 Passphrase / Password：密码登录模式的密码
 Port：端口（默认22）
 Timeout (ms)：超时时间（毫秒）默认300000
```

配置完成后，点击 Test Configuration 测试一下是否可以连接上，如果成功会返回 success，失败会返回报错信息，根据报错信息改正即可。

{% asset_img ClassName 12.webp %}

接下来进入我们创建的任务，点击"构建"，增加 2 行代码，意思是将 dist 里面的东西打包成一个文件，因为我们要传输。

```
 cd dist&&
 tar -zcvf dist.tar.gz *
```

点击"构建后操作"，增加构建后操作步骤，选择 send build artificial over SSH，
参数说明：

{% blockquote %}

- Name:选择一个你配好的 ssh 服务器
- Source files ：写你要传输的文件路径
- Remove prefix ：要去掉的前缀，不写远程服务器的目录结构将和 Source files 写的一致
- Remote directory ：写你要部署在远程服务器的那个目录地址下，不写就是 SSH Servers 配置里默认远程目录
- Exec command ：传输完了要执行的命令，我这里执行了解压缩和解压缩完成后删除压缩包 2 个命令
  {% endblockquote %}

{% asset_img ClassName 13.webp %}

现在当我们在本地发出一个 git push，过一会就会发现我们的服务器上已经部署好了最新的代码

至此，我们的自动化部署也完成了；
但是如果过程中有异常怎么办，或是我们想知道每次 Jenkins 运行的日志及运行结果，可以通过配置邮件服务来让 Jenkins 每次完成任务后通知相关人员。

## 11.实现邮件提醒

这里我们不用 E-mail Notification，因为它的邮件服务功能太少，无法自定义邮件内容及自定义触发钩子，而且只能在异常情况下才能发邮件。
我们使用 Editable Email Notification 这个。

打开系统管理-系统配置-Extended E-mail Notification，不是系统管理-系统配置-邮件通知，千万不要配错了，否则不起作用。配置一下用来发邮件的邮箱，我这里用的是我自己的 qq 邮箱。

{% asset_img ClassName 14.png %}

要是用别的厂家的邮箱服务就查下别的邮箱厂家 smtp 怎么配，用 qq 邮箱的除了 user Name 和 password 其他的和我写一样就行。
另外 password 写的不是 qq 邮箱的密码，而是开启 smtp 服务后发短信获取的密码。

打开创建的那个任务，增加"构建后操作"步骤选择 Editable Email Notification，Project Recipient List 那里写你要发给谁邮件，可以多个，用分号隔开。

{% asset_img ClassName 15.png %}

然后点击 Advanced Settings-Triggers-Add Trigger，选择 always，意思是无论什么情况任务执行完就发邮件，也可以选择其他模式，如任务执行异常了才发邮件。

这里配置的接收邮件的地址也是我的 qq 邮箱，这个可以根据自己公司的工作流程配。

现在当我们在本地修改代码后发出一个 git push，Jenkins 自动构建部署完成后就会给我发一封邮件，邮件附件里会有本次任务的日志。

至此，我们的邮件提醒功能也配置完了。

## 12.小结

通过上面这个案例，我们搭建了一套简单的自动化工作流，只需要在本地发起一个 git 提交，就可以在云端自动化构建，自动化部署，部署完成或出现异常后自动邮件通知，让持续集成、持续交付、持续部署变得简单易操作，解放了人力构建部署的生产力，也统一了构建环境，真实线上的 CI 服务配置比这个要复杂，大体流程可以参考下阮一峰老师的这篇文章:

持续集成是什么？：http://www.ruanyifeng.com/blog/2015/09/continuous-integration.html

Jenkins 还有很多强大的特性，如 Pipeline，slave 等，插件也很丰富，社区生态也很好，如果公司暂时没有自行搭建 CI 服务的能力，使用免费开源的 Jenkins 是很好的选择。另外，如果你的项目是开源项目，也可以使用 Travis CI 做持续集成，这个配置起来比 Jenkins 简单

# 二.基于 gitlab 的 CI/CD 工作流程

## 1.gitlab-ci && 自动化部署工具的运行机制

(1) 通过在项目根目录下配置 .gitlab-ci.yml 文件，可以控制 ci 流程的不同阶段，例如 install/检查/编译/部署服务器。
gitlab 平台会扫描.gitlab-ci.yml 文件，并据此处理 ci 流程

{% asset_img ClassName 16.jpg %}

（2）ci 流程在每次团队成员 push/merge 后之后触发。每当你 push/merge 一次，gitlab-ci 都会检查项目下有没有.gitlab-ci.yml 文件，如果有，它会执行你在里面编写的脚本，并完整地走一遍从 intall => eslint 检查=>编译 =>部署服务器的流程

{% asset_img ClassName 17.jpg %}

(3)gitlab-ci 提供了指定 ci 运行平台的机制，它提供了一个叫 gitlab-runner 的软件，只要在对应的平台(机器或 docker)上下载并运行这个命令行软件，并输入从 gitlab 交互界面获取的 token,就可以把当前机器和对应的 gitlab-ci 流程绑定，也即：每次跑 ci 都在这个平台上进行。

(4).gitlab-ci 的所有流程都是可视化的，每个流程节点的状态可以在 gitlab 的交互界面上看到，包括执行成功或失败。因为它的执行看上去就和多节管道一样，所以我们通常用“pipeLine”来称呼它

(5).不同 push/merge 所触发的 CI 流程不会互相影响，也就是说，你的一次 push 引发的 CI 流程并不会因为接下来另一位同事的 push 而阻断，它们是互不影响的。这一个特点方便让测试同学根据不同版本进行测试。

## 2.gitlab-ci 涉及的抽象概念

### Pipeline & Job

Pipeline 是 Gitlab 根据项目的.gitlab-ci.yml 文件执行的流程，它由许多个任务节点组成, 而这些 Pipeline 上的每一个任务节点，都是一个独立的 Job

Job 在 YML 中的配置我们将会在下面介绍，现在需要知道的是：每个 Job 都会配置一个 stage 属性，来表示这个 Job 所处的阶段。

一个 Pipleline 有若干个 stage,每个 stage 上有至少一个 Job，如下图所示：

{% asset_img ClassName 18.webp %}

### Runner

Runner 可以理解为：在特定机器上根据项目的**.gitlab-ci.yml 文件，对项目执行 pipeline 的程序**。
Runner 可以分为两种：Specific Runner 和 Shared Runner

#### （1）Shared Runner

是 Gitlab 平台提供的免费使用的 runner 程序，它由 Google 云平台提供支持，每个开发团队有十几个。对于公共开源项目是免费使用的，如果是私人项目则有每月 2000 分钟的 CI 时间上限。

#### （2）Specific Runner

是我们自定义的，在自己选择的机器上运行的 runner 程序，gitlab 给我们提供了一个叫 gitlab-runner 的命令行软件，只要在对应机器上下载安装这个软件，并且运行 gitlab-runner register 命令，然后输入从 gitlab-ci 交互界面获取的 token 进行注册, 就可以在自己的机器上远程运行 pipeline 程序了。

#### 二者的区别

- Shared Runner 是所有项目都可以使用的，而 Specific Runner 只能针对特定项目运行
- Shared Runner 默认基于 docker 运行，没有提前装配的执行 pipeline 的环境，例如 node 等。而 Specific Runner 你可以自由选择平台，可以是各种类型的机器，如 Linux/Windows 等，并在上面装配必需的运行环境，当然也可以选择 Docker/K8s 等
- 私人项目使用 Shared Runner 受运行时间的限制，而 Specific Runner 的使用则是完全自由的。

### Executor

什么是 Executor？我们上面说过 Specific Runner 是在我们自己选择的平台上执行的，这个平台就是我们现在说到的“Executor”，我们在特定机器上通过 gitlab-runner 这个命令行软件注册 runner 的时候，命令行就会提示我们输入相应的平台类型。可供选择的平台一共有如下几种，下面是一张它们各方面特点的比较表格

{% asset_img ClassName 19.webp %}

为了简单起见，我下面的实践部分使用的是我自己的本地 Mac 机器作为 Executor，并且在注册时选择“Shell”作为 Executor 类型。

## 2.YML 文件的基本语法规则

CI 流程的运行控制，决定于项目根目录下编写的配置文件—— .gitlab-ci.yml，正因如此，我们需要掌握 YML 的基本语法规则。

YML 是一种编写配置文件的语言，比 JSON 更为简洁和方便，因此，我们首先要掌握的就是 YML 文件的编写语法。

一份简单的 YML 文件长下面这个样子：

```yml
install-job: # 注释
  tags:
    - sss
  stage: install
  script:
    - npm install
```

从这里我们就可以看出：

- YML 通过缩进组织层级
- YML 里允许通过#符号编写注释

在基本结构上，YML 和 JSON 也类似

- JSON 是由对象，数组，以及对象和数组的嵌套结构组成的
- YML 也是由对象，数组，以及对象和数组的嵌套结构组成的。

如下所示：

YML 中的数组写法

```
colors
  - red
  - blue
  - yellow
```

相当于 JSON 中的

```
{ "colors": ["red","blue","yellow"] }
```

YML 中的对象写法：

```
people:
name: zhangsan
age: 14
```

相当于 JSON 中的

```
{
  "people": {
     "name": "zhangsan"
     "age": 14
  }
}
```

当然也可以是数组和对象之间形成的嵌套结构

```
a:
  b:
    - d
  c: e
```

相当于

```
{
  "a": {
    "b": [ "d" ],
    "c": "e"
   }
}
```

从 JSON 到 YML 之间的过渡学习的注意要点：

- 你不再需要“{}”这种符号去区分层级边界了，你需要考虑使用缩进
- 这里可以使用注释，用#符号
- 如果不涉及特殊符号比如“[”，你一般是不需要給 YML 中的字符串加双引号或者单引号的（当然加了也可以）
- 了解了这些，对于编写一个 gitlab-ci 的 hello world 已经没有问题了。

当然 YML 还有着比 JSON 更为丰富的功能，比如用”&"符号和"<<:\*”符号可以实现的片段导入的功能，以及 gitlab-ci 提供的 include 关键字和 extend 关键字等提供的结构编排功能。这些我将在最后面的小节中讲解，这里暂时不多赘述

### gitlab-ci.yml 配置的特定关键字

在了解了 YML 文件的语法格式后，接下来需要了解的就是<font color="#FF0000"> gitlab-ci 独特的配置关键字 </font>，这些关键字将在.gitlab-ci.yml 中使用，并用来控制一个 pipeline 具体的运作过程

gitlab 提供了很多配置关键字，其中最基础和常用的有这么几个

- stages
- stage
- script
- tags

#### stages & stage

stages 定义在 YML 文件的最外层，它的值是一个数组，用于定义一个 pipeline 不同的流程节点

例如我们定义如下:

```
stages: # 分段
  - install
  - eslint
  - build
  - deploy
```

则在 Gitlab 交互界面中能够看到如下展示

{% asset_img ClassName 20.webp %}

我们上面说过：**Job 是 pipeline 的任务节点，它构成了 pipeline 的基本单元**

而 stage/script/tags 这三个关键字，都是作为 Job 的子属性来使用的,如下所示，install 就是我们定义的一个 Job

```
install:
  tags:
    - sss
  stage: install
  script:
    - npm install
```

#### stage

是一个字符串，且是 stages 数组的一个子项，表示的是当前的 pipeline 节点。

当前 stage 的执行情况能在交互面板上能看的清清楚楚：

正在执行是蓝色
尚未执行是灰色
执行成功是绿色
执行失败是红色

{% asset_img ClassName 21.webp %}
{% asset_img ClassName 22.webp %}

#### script

它是当前 pipeline 节点运行的 shell 脚本（以项目根目录为上下文执行）。

这个 script 是我们控制<font color="#FF0000"> **CI 流程的核心** </font>，我们所有的工作：从安装，编译到部署都是通过 script 中定义的 shell 脚本来完成的。

如果脚本执行成功，pipeline 就会进入下一个 Job 节点，如果执行失败那么 pipeline 就会终止

#### tags

tags 是当前 Job 的标记，这个 tags 关键字是很重要，因为 gitlab 的 runner 会通过 tags 去判断能否执行当前这个 Job

例如我们在 gitlab 的面板中能看到当前激活的 runner 的信息

"Gitlab 项目首页=> setting => CI/CD => Runners"

{% asset_img ClassName 23.webp %}

上面的这个 sss 就是当前 Runner 的 tags，这意味着：这个 runner 只会执行 tag 为 sss 的 Job。如果一个 Job 没有 tag 或者 tag 不是 sss,那么即使这个 Runner 是激活且空闲的，也不会去执行！

基本的 gitlab-ci 关键字就介绍结束了，有了这些知识对于编写一个 gitlab-ci 的”hello world”已经足够了。

## 3.gitlab-ci 实战

### 编写一个 gitlab-ci 的"hello world"

1.在平台上下载并安装 Gitlab-runner 命令行

我是在 Mac 上跑的 ci，所以下面的适用于 OSX 系统（如果是其他平台，可自行参考以下官方链接中的相关资料）
参考资料：https://docs.gitlab.com/runner/install/

依次运行：

```
sudo curl --output /usr/local/bin/gitlab-runner https://gitlab-runner-downloads.s3.amazonaws.com/latest/binaries/gitlab-runner-darwin-amd64
sudo chmod +x /usr/local/bin/gitlab-runner
```

备注：这个下载过程可能会很慢，你可以复制上面的链接到浏览器中翻墙下载，然后下载完毕再进行后续处理

2.初始化 gitlab-runner

```
cd ~
gitlab-runner install
gitlab-runner start
```

最后输出如下，说明成功了。

{% asset_img ClassName 24.webp %}

3.注册 Runner

运行完 gitlab-runner start 只是完成了初始化，接下来你还要通过注册才能运行 runner

参考链接：https://docs.gitlab.com/runner/register/index.html

注册 runner 只需要一条运行命令：

```
sudo gitlab-runner register
```

然后写入相应的 token,url 和 tag 等相关信息，就注册完毕了。
{% asset_img ClassName 25.webp %}

上面要求输入的 Runner 绑定的 token 和 url， 获取方式如下：

“Gitlab 项目首页=> setting => CI/CD => Runners => Specific Runners”

4.激活 Runner

注册完了可能还需要激活，这时我们可以看下面板，如果有个黑色的感叹号，这说明 runner 注册成功了，但是尚未激活（如果是绿色的说明已经激活，本步骤跳过）

{% asset_img ClassName 26.webp %}

激活方法是本地运行：

```
sudo gitlab-runner verify
```

输出 “ ... is alive” 再回去看 gitlab 面板里面的 Runner 参数变成绿色就是激活成功了

5.梳理和规划 Pipeline 的不同阶段和过程

在编写.gitlab-ci.yml 前，首先需要考虑的是我们的 pipeline 分几个阶段处理。

从前端工程师的角度出发，一个前端项目的 PipeLine 处理包括以下阶段

- <1> install 阶段

就是执行 npm install 命令,根据 package.json 安装 node_modules 依赖包

- <2> eslint 阶段

执行 eslint 检查，判断代码格式是否符合规范，如果不符合则 pipeline 终止。

在这之前，我先通过 npm install eslint 安装了 eslint 检查工具，然后在项目根目录下配置了.eslintrc 文件。这部分可自行参考相关资料，这里暂不多赘述。

- <3>build 阶段

编译生成生产代码，可以通过 webpack 之类的打包工具执行编译。当然可以通过框架提供的编译命令进行编译

- <4>deploy 阶段

deploy 也就是部署阶段，也就是把刚才 bulid 阶段生成的生产代码，部署到生产访问的服务器上。这里又具体有以下两部分工作要做

第一部分：申请服务器 & 安装 web 服务
准备工作不再赘述，反正确保能在浏览器上通过对应的 IP+路径 来访问 Web 页面即可

第二部分：部署资源（每次 pipeline 都进行）

我下面的示例中，是通过 scp 这一命令，将本地机器代码远程拷贝到云服务器上。

因为这一命令需要输入密码，所以通过 sshpass 命令携带密码再执行 scp：

```
sshpass -p $PASSWORD scp -r ./build $CUSTOM_USERNAME@$CUSTOM_IP:/var/www/html
```

注：Gitlab 有自定义变量的功能，例如我们觉得直接在 YML 中写入密码/账号等信息不太好，那么可以通过美元符号$写入一个预定义的变量，然后在 Gitlab 面板上输入它

{% asset_img ClassName 27.webp %}

7.编写.gitlab-ci.yml 配置文件

回顾一下之前 YML 语法规则和 gitlab-ci 配置关键字的知识，就不难编写出以下 YML 文件

```
stages: # 分段
  - install
  - eslint
  - build
  - deploy

cache: # 缓存
  paths:
    - node_modules
    - build

install-job:
  tags:
    - sss
  stage: install
  script:
    - npm install

eslint-job:
  tags:
    - sss
  stage: eslint
  script:
    - npm run eslint

build-job:
  tags:
    - sss
  stage: build
  script:
    - npm run build

deploy-job:
  tags:
    - sss
  stage: deploy
  script:
    - sshpass -p $PASSWORD scp -r ./build $CUSTOM_USERNAME@$CUSTOM_IP:/var/www/html
```

8.提交项目代码

OK！终于到最后一步了，commit 然后 push

可以看到 gitlab 的 pipeline 按照预期运行，直到全部通过
最后访问我们的网站，发现内容已经更新；

## 4.Gitlab-ci 坑点详解

### 1.Runner 未激活问题

有时候注册之后，查看面板上的 Runner 信息，可能会发现 Runner 处在未激活状态， 灰色

解决方法：

运行以下命令重新启动 runner

```
sudo gitlab-runner verify
sudo gitlab-runner restart
```

### 2.Job 一直挂起，没有 Runner 来处理

(1)首先考虑的是不是 Runner 没有激活，如果没有那么按上面方式处理

(2)还可能是 tag 没有匹配到，上面说过，Runner 注册时是要填写绑定 tag 的，如果你在 YML 里面编写 Job 没有带上 tag 是不会有自定义 Runner 来处理。解决方法:给 Job 加 tags

(3)最后一种可能：你连续注册了多个 Runner,这些 Runner 冲突了，或者是新注册的 Runner 和旧 Runner 使用了同一个 token,这时候的解决方法如下：
先删掉本地其他旧的 Runner

```
sudo gitlab-runner unregister --all-runners
```

然后重置 token,并使用更新后的 token 重新注册一个 Runner

### 3.specific Runner 被 Share Runner 抢占了 Job

有时候你可能会发现：你的 Job 并没有被你新建的 Runner 执行，而是被 Share Runner 抢先执行了。
你如果不想要 Share Runner，你可以在 Gitlab 面板上关掉


{% asset_img ClassName 28.webp %}

The End ~


同时欢迎关注我的个人微信公众号：
{% img https://www.xuanbiyijue.com//img/%E5%85%AC%E4%BC%97%E5%8F%B7%E4%BA%8C%E7%BB%B4%E7%A0%81.jpg 300 300 %}
