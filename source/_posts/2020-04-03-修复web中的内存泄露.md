---
title: 修复web中的内存泄露
categories:
  - 前端性能优化与工程化
  - null
tags:
  - null
  - null
date: 2020-04-03 08:16:48
top:
---

![](1.png)

# 一．最常见的内存泄露方法
往window、body上添加监听事件，卸载的时候忘记移除；
window.addEventListener(‘message’,this.onMessage.bind(this));

# 二．导致内存泄露的情况
## 1.addEventListener。
这是最常见的一种，调用 removeEventListener 进行清理。

## 2.setTimeout/setInterval。
如果你创建一个循环计时器（例如每 30 秒运行一次），则需要使用 clearTimeout 或 clearInterval 进行清理。

## 3.IntersectionObserver、 ResizeObserver、 MutationObserver 等。
这些新颖的 API 非常方便，但它们也可能泄漏。如果你在组件内部创建一个组件并将其附加到全局可用元素，则需要调用 disconnect() 进行清理。

## 4.Promise, Observable, EventEmitter等。
如果你设置了侦听器，但忘记了停止侦听，则任何用于设置侦听器的编程模型都可能会造成内存泄漏。（如果 Promise 从未得到解决或拒绝，则可能会泄漏，在这种情况下，附加到它的任何 .then() 回调都会泄漏。）

## 5.全局对象存储。
Redux 之类的状态是全局的，如果你不小心，可以持续为其添加内存，并且永远都不会被清除

## 6.无限的 DOM 增长。
如果在没有虚拟化(https://github.com/WICG/virtual-scroller#readme)的情况下实现无限滚动列表，则 DOM 节点的数量将会无限增长

# 三．分析工具
1.Chrome Dev Tools中，选择的工具是“内存（Memory）”标签中的“堆快照（heap snapshot）”
![](2.png)


堆快照工具可以捕获主线程、Web Worker 或 iframe 的内存。
当你点击“获取快照（take snapshot）”按钮时，你已经捕获了该网页上特定 JavaScript VM 中的所有活动对象。这包括 window 所引用的对象，setInterval 回调所引用的对象等。可将其视为时间暂停后，代表该网页使用的所有内存。

2.在你觉得可能发生内存泄露的操作前后，进行两次快照，比如打开和关闭某个弹窗
![](3.png)

但是，如果你的程序很复杂，那么可能会在两个快照之间看到大量的泄漏对象。
这就很棘手了，因为并非所有这些都是真正的泄漏。
比如，其中有些可能只是正常用法——某些对象被取消分配，而另一个对象被优先分配；或者某些对象以某种方式被缓存，以便稍后进行清理，等等。
就需要我们进一步精确地分析；

# 四.精确分析
## 1.最好方法是多次重复泄漏情况。
例如，你不仅只是执行一次打开和关闭模式对话框这种操作，可以将其打开和关闭 7 次。（7 是一个质数。）然后你可以检查堆快照 diff，以查看是否有什么对象泄漏7次。（或14次或21次。）
![](4.png)

(1)截图显示了六个堆快照捕获，其中有多个对象泄漏了7次
(2)为什么应该按对象数而不是总内存进行排序?

如果你按总内存对堆快照差异进行排序，那么它将向你显示一堆数组、字符串和对象——其中大多数可能与泄漏无关。你真正想要找到的是事件侦听器，但是与它所引用的内容相比，占用的内存很小。

所以，如果按泄漏对象的数量进行排序，则会看到 7 个事件监听器。可能是 7 个组件和 14 个子组件等等。“7” 应该像腰间盘一样突出，因为它是一个不寻常的数字。而且，无论你重复该场景多少次，都应该确切的看到泄漏的对象数量。这样可以快速找到泄漏源。

## 2.retainer树
（1）堆快照差异还将向你显示一个 “retainer” 链，该链显示哪些对象指向哪些其他对象，从而使内存保持活动状态。这样可以弄清楚泄漏对象的分配位置。

![](5.png)

（2）retainer 链将向你显示哪个对象正在引用泄漏的对象。
读取它的方式是每个对象都由其下面的对象引用。点击可以帮你指向内存泄露的文件代码位置；

在上面的示例中，有一个名为 someObject 的变量，该变量由闭包（也称为“context上下文”）引用，并由事件侦听器引用。如果单击源链接，它将带你到 JavaScript 声明：

```bash
class SomeObject () { /* ... */ }
const someObject = new SomeObject();
const onMessage = () => { /* ... */ };
window.addEventListener('message', onMessage);
```

# 五.使用heap snapshot堆快照的几个限制
1.如果保存并重新加载快照文件，则所有文件引用都将会丢失到分配对象的位置。
所以保存和发送堆快照文件再打开是没有用的。

2.涉及到WeakMap,因为他们的键是对象，弱引用的，所以会自动释放内存，不会导致内存泄露的情况；
在堆快照工具中可以忽略它们；

3.Chrome 根据对象的原型来对对象进行分类。
所以使用实际类或函数的次数越多，使用匿名对象的次数越少，则更容易看到泄漏的确切内容。

# 六.内存泄漏自动分析
1.目前还没有找到一种自动检测内存泄漏的好方法。Chrome 有非标准的 performance.memory API，但出于隐私方面的考虑它没有非常精确的粒度(https://bugs.webkit.org/show_bug.cgi?id=80444)，因此你不能真正在生产中用它来识别泄漏。W3C 网络性能工作组过去讨论了内存 工具，但尚未就取代该 API 的新标准达成共识。

2.在实验室或综合测试环境中，你可以用 Chrome 标志 –enable-precise-memory-info。
还可以通过调用专有的 Chromedriver 命令 :takeHeapSnapshot 创建堆快照文件。
但是这也具有上述相同的限制——你可能想要连续获取三个并丢弃前两个。

3.由于事件监听器是最常见的内存泄漏源，因此我使用的另一种技术是对 monkey-patch 的 addEventListener 和 removeEventListener API进行计数，从而进行计数引用并确保它们返回零。

4.在 Chrome Dev Tools 中，你还可以使用专有的 getEventListeners() API 来查看事件监听器附加到特定元素。注意，这只能在 Dev Tools 中使用。

# 七.总结
与大多数性能问题一样，少量预防胜过大量的治疗。
前期进行综合测试是很有必要的，而不是在事实发生后尝试调试内存泄漏。尤其是如果页面上存在多个泄漏，则可能会变成洋葱剥皮的修复——你先修复一个泄漏，然后查找另一个泄漏，然后重复。
最后，良好的code review代码审查 也可以帮助捕获常见的内存泄漏。

参考文章: Fixing memory leaks in web applications

同时欢迎关注我的个人微信公众号：
{% img https://www.xuanbiyijue.com//img/%E5%85%AC%E4%BC%97%E5%8F%B7%E4%BA%8C%E7%BB%B4%E7%A0%81.jpg 300 300 %}