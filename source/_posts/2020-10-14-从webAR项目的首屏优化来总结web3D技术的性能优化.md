---
title: 从webAR项目的首屏优化来总结web3D技术的性能优化
categories:
  - 实验室
  - null
tags:
  - null
  - null
date: 2020-10-14 21:15:10
top:
---


# 一．削减模型图元数据

## 1.unity中，利用已有的插件
UnityMeshSimplify提供了让我们在Unity中自由调整模型精度并序列化的能力。使用了它，在视觉效果损失较低的情况下，平均降低所有场景30%的图元数据大小：
{% asset_img ClassName 1.jpg %}

## 2.消减不必要的图元数据
（1）图元的最基本单元是顶点，一个顶点有包含着若干信息，在绘制时这些顶点数据将会被送入顶点着色器进行一系列处理，然后进入光栅化阶段。而一个顶点的信息，最常见来看，包含：
{% asset_img ClassName 2.jpg %}
（2）如果使用场景没有光照，法线和切线数据就没有作用，可以将其删除，我在UnityToolkit中添加了Unlit(No Normals)选项来让导出时可以自动剔除这两项：

# 二．压缩纹理
（1）压缩纹理是一种游戏领域常用的纹理压缩技术，其依赖于特定硬件实现，本质上可以以固定速率交由GPU即时解压
（2）相同尺寸的图片，压缩前后，在GPU占用的内存一样
故压缩后的 png/jpg 提高了加载速度，但对于渲染过程并没有优化。
（3）许多设备都有可直接用于渲染的 GPU 压缩纹理(compress texture)格式。
压缩纹理可比由 png 直接转换的纹理减少5倍或以上的大小。
如果直接提供压缩纹理格式，则不需要进行 png 的转码过程且可大大减少纹理内存。
{% asset_img ClassName 3.png %}

## 1.优点：
（1）内存：大幅节省内存开销。
（2）解码：免去图片解码开销，直接丢给GPU，提升启动性能。
（3）采样：提升纹理随机采样性能。
（4）可控：由于其本身就是在JSHeap上申请的buffer，所以在Web容器下，提供了一个（5）可以精确控制内存的方式。

## 2.缺点
（1）压缩纹理是有损压缩，会对图片的质量有一定减损，这个需要视项目而定。
（2）压缩纹理的传输体积可能比JPG/PNG方案要高1~4倍。
（3）压缩纹理要求POT，即长宽都是二的幂次。
（4）对于iOS的PVRTC，还要求长宽相等。
（5）由于压缩纹理格式在不同平台不能通用，加上降级需要三份资源，对于离线加速技术不友好。

## 3.POT的解决办法~图集（雪碧图）
（1）将四个500x500的地标图片拼到了一张1024x1024的图集中，来满足压缩纹理的需求。
（2）图集还有别的优势，就是减少内存碎片，减少数据提交次数，某些情况下还可以减少资源请求。

## 4.压缩策略
安卓下使用ASTC和iOS下使用PVRTC的策略来进行纹理压缩

# 三．进一步的模型压缩
## 1.使用decro+wasm压缩
之前写过一篇文章有介绍
[《webGL建模、调优和未来的发展》](https://www.xuanbiyijue.com/2019/10/09/webGL%E5%BB%BA%E6%A8%A1%E3%80%81%E8%B0%83%E4%BC%98%E5%92%8C%E6%9C%AA%E6%9D%A5%E7%9A%84%E5%8F%91%E5%B1%95/)

## 2.GZIP压缩
老朋友，不过多介绍；

## 3.普通图片资源压缩
使用tinyPNG，或者谷歌最近使用wasm技术进行各种图片压缩的项目~squoosh；

# 四．减少资源请求次数
## 1.用glb替换 gltf+bin文件
glTF有它的二进制形式GLB，其可以将索引、纹理、图元数据等等都打包到一个二进制文件中，大幅降低请求数量；

# 五．其他优化
## 1.交互优化
（1）保证用户操作时不卡顿的优先级>首屏加载速度
可以在第一帧将所有物体渲染一遍，再结束Loading，这增加了些许的加载时间，但保证了整个过程中不会卡顿；
## 2.渐进式展示
（1）总是先展示静态图片，3D资源加载、解析、提交GPU成功后，才无缝切换为3D动画。
（2）注意要保证静态图片和3D场景的姿态完全一致，从而达到视觉上无缝切换的目的。
## 3.时间分片
（1）若模型比较复杂，首帧渲染会卡住用户操作。可以采用时间分片策略，将五个模型拆分为五次渲染，每次间隔200ms，留给用户操作的时间
（2）可以用setTimeout定时器实现一个，代码如下
```js
loadOne = (index: number, total: number) => {
  const { state, event } = this.getGame();

  const actor = this.actors[state.typeList[index]];
  actor.visible = true;

  event.addOnce('MainRendererIsFinished', () => {
    actor.visible = false;
    if (index === total - 1) {
      event.trigger('Ready');
    } else {
      setTimeout(() => this.loadOne(index + 1, total), 200);
    }
  });
}
```

## 4.酷炫粒子动画效果
使用Lottie在web上实现AE中的复杂效果；

## 5.保障动画性能
（1）粒子运动完全GPU运算
（2）优化粒子发射器
（3）合并发射器
（4）减少拖尾的使用
## 6.工程自动化
（1）unity引擎工作流
（2）webpak工作流

# 六.参考资料
《如何在页面极速渲染3D模型》
https://cloud.tencent.com/developer/article/1552903
《亿级前端项目中的3D技术-支付宝2020年新春活动的背后》
https://zhuanlan.zhihu.com/p/115989449



同时欢迎关注我的个人微信公众号：
{% img https://www.xuanbiyijue.com//img/%E5%85%AC%E4%BC%97%E5%8F%B7%E4%BA%8C%E7%BB%B4%E7%A0%81.jpg 300 300 %}