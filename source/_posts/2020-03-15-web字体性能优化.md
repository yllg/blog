---
title: web字体性能优化
categories:
  - 前端性能优化与工程化
  - null
tags:
  - null
  - null
date: 2020-03-15 07:56:11
top:
---


# 背景介绍
最近工作中web画板，有个文字的优化问题
![](1.gif)

有两个问题：
中文字体体积太大导致加载时间过长
字体加载完成前显示默认字体，加载后会替换，出现闪烁的问题，想在加载完成前不展示内容

刚好看到最近京东凹凸实验室有一篇实践，觉得很不错，故记录下来

# 使用web自定义字体
CSS Fonts Module Level 3 定义的 @font-face

```bash
@font-face {
    font-family: "webfontFamily"; /* 名字任意取 */
    src: url("webfont.woff2") format("woff2"),
         url("webfont.woff") format("woff"),
         url("webfont.ttf") format("truetype");
    font-style:normal;
    font-weight:normal;
}
```

将字体源文件上传cdn，让 @font-face 规则的 url 值为该字体的地址，最后将这个规则应用在 Web 文字上，就可以实现字体的预览效果。
但是，字体体积太大，会导致加载时间过长；如果用户弱网情况下，等待会更久；

# 中文字体体积太大导致加载时间过长
## 原因
中文字体相较于英文字体体积为什么这么大，这主要是两个方面的原因：
{% blockquote %}
中文字体包含的字形数量很多，而英文字体仅包含26个字母以及一些其他符号。
中文字形的线条远比英文字形的线条复杂，用于控制中文字形线条的位置点比英文字形更多，因此数据量更大。
{% endblockquote %}

## 如何减小字体文件体积
### unicode-range
unicode-range 属性一般配合 @font-face 规则使用，它用于控制特定字符使用特定字体。
但是它并不能减小字体文件的大小，感兴趣的读者可以试试。

CSS unicode-range特定字符使用font-face自定义字体

### fontmin
fontmin 是一个纯 JavaScript 实现的字体子集化方案。
前文谈到，中文字体体积相较于英文字体更大的原因是其字形数量更多，那么精简一个字体文件的思路就是将无用的字形移除：

```bash
// 伪代码
const text = '字体预览'
const unicodes = text.split('').map(str => str.charCodeAt(0))
const font = loadFont(fontPath)
font.glyf = font.glyf.map(g => {
 // 根据unicodes获取对应的字形
})
```

实际上的精简并没有这么简单，因为一个字体文件由许多表(table)构成，这些表之间是存在关联的
例如 maxp 表记录了字形数量，loca 表中存储了字形位置的偏移量。
同时字体文件以 offset table(偏移表) 开头，offset table记录了字体所有表的信息，因此如果我们更改了 glyf 表，就要同时去更新其他表。

先来了解一下字体文件的结构：
![](2.png)

上面的结构限于字体文件只包含一种字体，且字形轮廓是基于 TrueType 格式（决定 sfntVersion 的取值）的情况，因此偏移表会从字体文件的0字节开始。
如果字体文件包含多个字体，则每种字体的偏移表会在 TTCHeader 中指定，这种文件不在文章的讨论范围内。

对于一个字体文件，无论其字形轮廓是 TrueType 格式还是基于 PostScript 语言的 CFF 格式，其必须包含的表有 cmap、head、hhea、htmx、maxp、name、OS/2、post 这八个；
如果其字形轮廓是 TrueType 格式，还有cvt、fpgm、glyf、loca、prep、gasp 六张表会被用到。
这六张表除了 glyf 和 loca 必选外，其它四个为可选表。

### fontmin 截取字形原理
fontmin 内部使用了 fonteditor-core，核心的字体处理交给这个依赖完成，fonteditor-core 的主要流程如下：
![](3.png)

### fontmin不足之处
fonteditor-core 在截取字体的过程中只会对前文提到的十四张表进行处理，其余表丢弃。
每个字体通常还会包含 vhea 和 vmtx 两张表，它们用于控制字体在垂直布局时的间距等信息，
如果用 fontmin 进行字体截取后，会丢失这部分信息，可以在文本 垂直显示 时看出差异（右边为截取后）：
![](4.png)

fontmin 使用方法
服务器接受到客户端发来的请求后，通过 fontmin 截取字体，fontmin 会返回截取后的字体文件对应的 Buffer，将 Buffer 转为 base64 格式嵌入在 @font-face 中返回给客户端，然后客户端将该 @font-face 以 CSS 形式插入 head 标签中即可。

对于固定的预览内容，我们也可以先生成字体文件保存在 CDN 上，但是这个方式的缺点在于如果 CDN 不稳定就会造成字体加载失败。如果用上面的方法，每一个截取后的字体以 base64 字符串形式存在，则可以在服务端做一个缓存，就没有这个问题。利用 fontmin 生成字体子集代码如下：

```bash
const Fontmin = require('fontmin')
const Promise = require('bluebird')

async function extractFontData (fontPath) {
  const fontmin = new Fontmin()
    .src('./font/senty.ttf')
    .use(Fontmin.glyph({
      text: '字体预览'
    }))
    .use(Fontmin.ttf2woff2())
    .dest('./dist')

  await Promise.promisify(fontmin.run, { context: fontmin })()
}
extractFontData()
```

对于固定预览内容我们可以预先生成好分割后的字体，对于用户输入的动态预览内容，我们当然也可以按照这个流程：
{% blockquote %}
获取输入 -> 截取字形 -> 上传 CDN -> 生成 @font-face -> 插入页面
{% endblockquote %}

按照这个流程来客户端需要请求两次才能获取字体资源（在 @font-face 插入页面后才会去真正请求字体），并且截取字形和上传 CDN 这两步时间消耗也比较长，有没有更好的办法呢？

我们知道字形的轮廓是由一系列位置点确定的，因此我们可以获取 glyf 表中的位置点坐标，通过 SVG 图像将特定字形直接绘制出来。
获取位置信息以及生成 path 标签我们可以借助 opentype.js 完成，客户端得到输入字形的 path 元素后，只需要遍历生成 SVG 标签即可。

# 字体加载完成前不展示预览内容
在浏览器的字体显示行为中存在阻塞期和交换期两个概念
以 Chrome 为例，在字体加载完成前，会有一段时间显示空白，这段时间被称为阻塞期。
如果在阻塞期内仍然没有加载完成，就会先显示后备字体，进入交换期，等待字体加载完成后替换。
这就会导致页面字体出现闪烁，与我想要的效果不符。
而 font-display 属性控制浏览器的这个行为，是否可以更换 font-display 属性的取值来达到我们的目的呢？

## font-display
字体的显示策略和 font-display 的取值有关，浏览器默认的 font-display 值为 auto，它的行为和取值 block 较为接近。

{% blockquote %}
1.第一种策略是 FOIT(Flash of Invisible Text)，FOIT 是浏览器在加载字体的时候的默认表现形式，其规则如前文所说，最开始会有空白显示，再使用后备字体，最后替换显示
2.第二种策略是 FOUT(Flash of Unstyled Text)，FOUT 会指示浏览器 直接使用后备字体直至自定义字体加载完成，对应的取值为 swap。
{% endblockquote %}

两种不同策略的应用：Google Fonts FOIT 汉仪字库 FOUT

我希望的效果是字体加载完成前不展示预览内容，FOIT 策略最为接近。
但是 FOIT 文本内容不可见的最长时间大约是3s， 如果用户网络状况不太好，那么3s过后还是会先显示后备字体，导致页面字体闪烁，因此 font-display 属性不满足要求。

查阅资料得知，CSS Font Loading API在 JavaScript 层面上也提供了解决方案：

## FontFace、FontFaceSet
我们可以通过 FontFace 构造函数构造出一个 FontFace 对象：

```bash
const fontFace = new FontFace(family, source, descriptors)
```
{% blockquote %}
family
字体名称，指定一个名称作为 CSS 属性 font-family 的值，
source
字体来源，可以是一个 url 或者 ArrayBuffer
descriptors optional
style：font-style
weight：font-weight
stretch：font-stretch
display: font-display （这个值可以设置，但不会生效）
unicodeRange：@font-face 规则的 unicode-ranges
variant：font-variant
featureSettings：font-feature-settings
{% endblockquote %}

构造出一个 fontFace 后并不会加载字体，必须执行 fontFace 的 load 方法。
load 方法返回一个 promise，promise 的 resolve 值就是加载成功后的字体。
但是仅仅加载成功还不会使这个字体生效，还需要将返回的 fontFace 添加到 fontFaceSet。

使用方法如下：
```bash
/**
  * @param {string} path 字体文件路径
  */
async function loadFont(path) {
  const fontFaceSet = document.fonts
  const fontFace = await new FontFace('fontFamily', `url('${path}') format('woff2')`).load();
  fontFaceSet.add(fontFace)
}
```

因此，在客户端我们可以先设置文字内容的 CSS 为 opacity: 0， 等待 await loadFont(path) 执行完毕后，再将 CSS 设置为 opacity: 1, 这样就可以控制在自定义字体加载未完成前不显示内容。

# 参考
Web 中文字体性能优化实践
前端字体截取
Scalable Vector Graphics
FontFace
FontFaceSet
fontmin
fonteditor-core
TrueType-Reference-Manual
OpenType-Font-File

同时欢迎关注我的个人微信公众号：
{% img https://www.xuanbiyijue.com//img/%E5%85%AC%E4%BC%97%E5%8F%B7%E4%BA%8C%E7%BB%B4%E7%A0%81.jpg 300 300 %}