---
title: nodejs进程、通信、集群、进程管理
categories:
  - NodeJS
  - null
tags:
  - null
  - null
date: 2021-09-16 00:24:03
top:
---


# 一.进程定义：
（1）启动一个程序的时候，操作系统会为该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，我们把这样的一个运行环境叫进程。
（2）Node.js 中的进程 Process 是一个全局对象，无需 require 直接使用，给我们提供了当前进程中的相关信息。

# 二.进程process和线程thread的关系：
## 1.根本区别：
（1）进程，是操作系统<font color="#FF0000"> 资源分配 </font>的基本单位，线程不拥有系统资源，但可以访问隶属于进程的资源，同一进程的所有线程共享该进程的所有资源。资源包括：内存，cpu，IO；
（2）线程，是处理器CPU <font color="#FF0000"> 任务调度和执行 </font>的基本单位；
## 2.资源开销：
（1）每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；进程间通信需要各种通信方式；
（2）线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。线程通信因为共享一块内存，只要保证指针一致就行；
## 3.包含关系：
（1）线程是进程的一部分，一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程（主线程）。
（2）nodejs大部分情况下一个进程里面是一个线程，单线程；
## 4.内存分配：
（1）同一进程的线程共享本进程的地址空间和资源，而进程之间的地址空间和资源是相互独立的
（2） 当一个进程关闭之后，操作系统会回收进程所占用的内存。即使其中任意线程因为操作不当导致内存泄漏，都会被正常回收的；
## 5.影响关系：
（1）因为进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响
（2）而线程之间没有单独的地址空间，一个线程死掉（崩溃）就等于整个进程死掉，所以多进程要比多线程健壮。

# 三.补充下协程 coroutines相关知识
## 1.什么是协程
协程运行在线程之上，当一个协程执行完成后，可以选择主动让出，让另一个协程运行在当前线程之上。
** 协程并没有增加线程数量，只是在线程的基础之上通过分时复用的方式运行多个协程 **
而且协程的切换在用户态完成，切换的代价比线程从用户态到内核态的代价小很多。

{% asset_img ClassName 1.jpg %}

## 2.协程的适用场景和注意事项
（1）在有大量IO操作业务的情况下，采用协程替换线程，可以到达很好的效果，一是降低了系统内存，二是减少了系统切换开销，因此系统的性能也会提升。
（2）在协程中尽量不要调用阻塞IO的方法，比如打印，读取文件，Socket接口等，除非改为异步调用的方式；
（3）** 协程只有在IO密集型的任务中，配合异步IO才能发挥最大威力 **

# 四.进程间如何进行通信
## （1）通过stdin/stdout传递json
最直接的方式，适用于能够拿到“子”进程handle 句柄的场景，适用于关联进程之间通信，
缺点：无法跨机器；
## （2）IPC通信：
最native（地道）的方式，比上一种“正规”一些；
缺点：具有同样的局限性，无法跨机器；
## （3）通过sockets：
最通用的方式，有良好的跨环境能力
缺点：存在网络的性能损耗；
## （4）借助message queue：
最强大的方式，既然要通信，场景还复杂，不妨扩展出一层消息中间件，漂亮地解决各种通信问题；
## （5）Redis
基本思路与message queue类似
Redis自带Pub/Sub机制（即发布-订阅模式），适用于简单的通信场景，比如一对一或一对多并且不关注消息可靠性的场景；
## （6）实现进程间的状态共享，或者数据共享
使用Kafka这类消息队列工具，或者其他类似工具。
## （7）nodejs中的进程通信
1）在 NodeJS 中，子进程对象使用 send() 方法实现向主进程发送数据，message 事件实现主进程监听由子进程发来的数据。
2）IPC 进程间通信（Inter-Process Communication）
IPC分为 本地过程调用(LPC)和 远程过程调用(RPC)，nodejs中使用的是<font color="#FF0000"> RPC </font>
父进程会在创建子进程之前，会先创建 IPC 通道并监听这个 IPC；
然后再创建子进程，通过环境变量（NODE_CHANNEL_FD）告诉子进程和 RPC 通道相关的文件描述符
子进程启动的时候根据文件描述符连接 IPC 通道，从而和父进程建立连接。

{% asset_img ClassName 2.jpg %}

# 五.多进程架构
node 的多进程架构是<font color="#FF0000"> 主从模式 </font>，如下所示：
{% asset_img ClassName 3.png %}

## 1.nodejs的child_process 模块
有四种创建进程的方式，后三个都是第一个spawn的延伸；
- child_process.spawn(command, args)
- child_process.fork(modulePath, args)
- child_process.exec(command, options)
- child_process.execFile(file, args[, callback])

{% asset_img ClassName 4.jpg %}

### （1）child_process.spawn()方法
启动一个子进程来执行命令；
可以执行shell命令，各种cli工具，webpack源码都使用到了，也是shelljs这个库的底层原理；
1）该方法第三个参数有一个 stdio 选项
- 选项用于配置在父进程和子进程之间建立的管道。
- 默认情况下，子进程的 stdin、 stdout 和 stderr 会被重定向到 ChildProcess 对象上相应的 subprocess.stdin、subprocess.stdout 和 subprocess.stderr 流。
- 这相当于将 options.stdio 设置为 ['pipe', 'pipe', 'pipe']。

### （2）child_process.fork()方法
与 spawn()类似，不同点在于它创建 Node 子进程需要执行 js 文件；
```
var fork = require('child_process').fork;
var cpus = require('os').cpus();
// 根据CPU数创建多个进程
for(var i = 0; i < cpus.length; i++){
    fork('./worker.js');
}
```

在 linux 中，我们通过 ps aux | grep worker.js 查看进程
下面是著名的主从模式，Master-Worker

{% asset_img ClassName 5.png %}

### （3）exec(): 
启动一个子进程来执行命令，与 spawn()不同的是，其接口不同，它有一个回调函数获知子进程的状况

### （4）execFlie(): 
启动一个子进程来执行可执行文件；

### （5）之间的区别：
- spawn()与 exec()、execFile()不同的是，后两者创建时可以指定 <font color="#FF0000"> timeout </font> 属性设置超时时间，一旦创建的进程超过设定的时间就会被杀死；
- exec()与 execFile()不同的是，exec()适合执行已有<font color="#FF0000"> 命令 </font>，execFile()适合执行<font color="#FF0000"> 文件 </font>。

## 2.nodejs的cluster模块
（1）简单来说，cluster模块是 ** child_process 模块和 net 模块的组合应用 **
cluster.fork() 源码中会调用 child_process 的 fork 方法来启动新的进程
（2）主进程监听一个端口，子进程不监听端口，通过主进程分发请求到子进程；
（3）cluster 启动时，内部会启动 TCP 服务器，将这个 TCP 服务器端 socket 的文件描述符发给工作进程。在 cluster 模块应用中，一个主进程只能管理一组工作进程，其运作模式没有child_process 模块那么灵活，但是更加稳定；
（4）为了让集群更加稳定和健壮，cluster 模块暴露了许多事件：
- fork
- online
- listening
- disconnect
- exit
- setup
这些事件在进程间消息传递的基础了完成了封装，保证了集群的稳定性和健壮性。

## 3.work_thread 工作线程
（1）是nodejs v10.5.0版本新增的
（2）和child_process的区别
1）work_thread工作线程对于执行 <font color="#FF0000"> CPU 密集型 </font>的 JavaScript 操作很有用；它们对 I/O 密集型的工作帮助不大，Node.js 内置的异步 I/O 操作比工作线程更高效。
2）与 child_process 或 cluster 不同，worker_threads 可以<font color="#FF0000"> 共享内存 </font>。 它们通过传输 ArrayBuffer 实例或共享 SharedArrayBuffer 实例来实现。

# 六.nodejs进程管理
## 1.cluster
### 1-1.cluster 是如何做到多个子进程监听一个端口？
cluster 模块应用 child_process 来创建子进程，主进程就是真实的监听端口启动服务；
子进程通过调用 cluster._getServer 方法，也就是 internal/cluster/child 中的 cluster._getServer 方法。
```
obj.once('listening', () => {

    cluster.worker.state = 'listening';

    const address = obj.address();

    message.act = 'listening';

    message.port = (address && address.port) || options.port;

    send(message);

  });
```

上面代码通过 send 方法，如果监听到 listening 发送一个消息给到主进程，主进程也有一个同样的 listening 事件，监听到该事件后将子进程通过 EventEmitter 绑定在主进程上，这样就完成了主子进程之间的关联绑定，并且只监听了一个端口。而主子进程之间的通信方式，就是我们常听到的 IPC 通信方式。
### 1-2.负载均衡原理
Node.js cluster 模块中的两个模块。
（1）<font color="#FF0000"> round_robin_handle.js </font>（非 Windows 平台应用模式）

这是一个轮询处理模式，也就是轮询调度分发给空闲的子进程，处理完成后回到 worker 空闲池子中

这里要注意的就是如果绑定过就会复用该子进程，如果没有则会重新判断，所以用浏览器去访问，你会发现每次调用的子进程 ID 都会不变。
（2）<font color="#FF0000"> shared_handle.js </font>（ Windows 平台应用模式）

通过将文件描述符、端口等信息传递给子进程，子进程通过信息创建相应的 SocketHandle / ServerHandle，然后进行相应的端口绑定和监听、处理请求。

## 2.PM2
PM2是nodejs的进程管理工具，可用它来简化很多node应用管理的繁琐任务，如性能监控、自动重启、负载均衡等，而且使用非常简单；
### 1.主要特性
（1）启动多个子进程，充分利用CPU
（2）子进程之间的负载均衡
（3）0秒重启
（4）界面友好
（5）提供进程交互接口，比如终端监控等
（6）日志管理
（7）SSH自动部署
（8）支持静态服务器功能；

### 2.架构图
{% asset_img ClassName 6.png %}

pm2包括satan进程、God Deamon守护进程、进程间的远程调用rpc、cluster等几个概念；
pm2采用了God Deamon守护进程，God进程启动后一直运行，它相当于cluster中的Master进程，守护着worker进程的正常运行；

### 3.执行流程
{% asset_img ClassName 7.png %}

每次命令行的输入都会执行一次satan程序，如果God进程不在运行，首先需要启动God进程。然后根据指令，satan通过rpc调用God中对应方法执行相应的逻辑。

### 4.依据什么重启服务？
（1）PM2采用<font color="#FF0000"> 心跳检测 </font>查看子进程是否处于活跃状态；每隔数秒向子进程发送心跳包，如果不回复，就kill改进程，重新cluster.fork() 一个新的进程；
（2）子进程自己可以监听错误，主动发消息让主进程杀死自己；
（3）node 子进程被杀死，自动重启代码的示例
在创建子进程的时候就让子进程监听 exit 事件，如果被杀死就重新 fork 一下；
如果有重启限制，比如一分钟最多重启5次，每次重启存下时间，进行判断即可。
```
var createWorker = function(){
    var worker = fork(__dirname + 'worker.js')
    worker.on('exit', function(){
        console.log('Worker' + worker.pid + 'exited');
        // 如果退出就创建新的worker
        createWorker()
    })
}
```


### 5.进程创建管理的原理
（1）进程创建的整体流程如下图
{% asset_img ClassName 8.jpg %}

这一方式涉及五个模块文件。
- CLI（lib/binaries/CLI.js）处理命令行输入，如我们运行的命令：
pm2 start pm2.config.js --env development

- API（lib/API.js）对外暴露的各种命令行调用方法，比如上面的 start 命令对应的 API->start 方法。
- Client （lib/Client.js）可以理解为命令行接收端，负责创建守护进程 Daemon，并与 Daemon（lib/Daemon.js）保持 RPC 连接。
- God （lib/God.js）主要负责进程的创建和管理，主要是通过 Daemon 调用，Client 所有调用都是通过 RPC 调用 Daemon，然后 Daemon 调用 God 中的方法。
- 最终在 God 中调用 ClusterMode（lib/God/ClusterMode.js）模块，在 ClusterMode 中调用 Node.js 的 cluster.fork 创建子进程。

（2）对于其他命令指令，比如 stop、restart 等，也是一样的通信流转过程；

## 3.其他node的进程管理工具
（1）forever
forever是一个简单的命令式nodejs的守护进程，能够启动，停止，重启App应用。
完全基于命令行操作，在forever进程之下，创建node的子进程，通过monitor监控node子进程的运行情况，一旦文件更新，或者进程挂掉，forever会自动重启node服务器，确保应用正常运行。

## 4.异常处理
使用node原生的API，写shell脚本来手动管理
（1）未捕获异常
Node.js 提供了 process.on('<font color="#FF0000"> uncaughtException </font>', handler) 接口来捕获异常，但是当一个 Worker 进程遇到未捕获的异常时，它已经处于一个不确定状态，此时我们应该让这个进程优雅退出：
- 关闭异常 Worker 进程所有的 TCP Server（将已有的连接快速断开，且不再接收新的连接），断开和 Master 的 IPC 通道，不再接受新的用户请求。
- Master 立刻 fork 一个新的 Worker 进程，保证在线的『工人』总数不变。
- 异常 Worker 等待一段时间，处理完已经接受的请求后退出。

（2）OOM（Out Of Menmory Error）、系统异常
当一个进程出现异常导致 crash 或者 OOM 被系统杀死时，不像未捕获异常发生时我们还有机会让进程继续执行，只能够让当前进程直接退出，Master 立刻 fork 一个新的 Worker。



GitHub: [GitHub链接](https://github.com/yllg/Algorithms-JS/tree/master/nodejs%E7%9B%B8%E5%85%B3/node-cluster)
欢迎小伙伴们star 💗❤️💖~~

同时欢迎关注我的个人微信公众号：
{% img https://www.xuanbiyijue.com//img/%E5%85%AC%E4%BC%97%E5%8F%B7%E4%BA%8C%E7%BB%B4%E7%A0%81.jpg 300 300 %}